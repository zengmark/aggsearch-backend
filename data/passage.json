{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1738547377448443905",
        "title": "Elasticsearch 基础概念与入门使用",
        "description": "elasticsearch 是一款非常强大的开源搜索引擎，具备非常多强大的功能，可以帮助我们从海量的数据中快速找到需要的内容。在电商网站搜索商品在 Google 搜索答案……elasticsearch结合kibana、Logstash、Beats，也就是elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域。",
        "content": "# ElasticSearch 的基础概念与入门使用\n\n## 前言\n\nelasticsearch 是一款非常强大的开源搜索引擎，具备非常多强大的功能，可以帮助我们从海量的数据中快速找到需要的内容。\n\n例如：\n\n- 在 Github 中搜索代码\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/QpXW7PpC-image.png)\n\n\n\n- 在电商网站搜索商品\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/kHFC1ZZw-image.png)\n\n\n- 在 Google 搜索答案\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/h4e4y70k-image.png)\n\n\n- ……\n\n\n\nelasticsearch结合kibana、Logstash、Beats，也就是elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域，而elasticsearch是elastic stack的核心，负责存储、搜索、分析数据。\n\nelasticsearch底层是基于**lucene**来实现的。\n\n**Lucene**是一个Java语言的搜索引擎类库，是Apache公司的顶级项目，由DougCutting于1999年研发。官网地址：https://lucene.apache.org/ 。\n\n\n\n## 基础概念\n\n### 文档\n\nelasticsearch 是面向 **文档** 存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化成 json 格式后存储在 elasticsearch 中，而 json 文档中往往包含很多的字段（Field），类似于数据库中的列。\n\n\n\n### 分词器\n\n作用：\n\n- 创建倒排索引时对文档分词\n- 用户搜索时，对输入的内容分词\n\n\n\n### 索引与映射\n\n**索引（Index）** ，就是相同类型的文档的集合。\n\n例如：\n\n- 所有用户文档，就可以组织在一起，称为用户的索引；\n- 所用商品的文档，可以组织在一起，称为商品的索引；\n- 所有订单的文档，可以组织在一起，称为订单的索引；\n\n```json\n# 商品索引\n{\n    \"id\": 1,\n    \"name\": \"电视机\",\n    \"category\": \"家电\",\n    \"price\": 599.99,\n    \"stock\": 50\n  },\n  {\n    \"id\": 2,\n    \"name\": \"手机\",\n    \"category\": \"电子设备\",\n    \"price\": 899.99,\n    \"stock\": 100\n  },\n  {\n    \"id\": 3,\n    \"name\": \"运动鞋\",\n    \"category\": \"服装\",\n    \"price\": 79.99,\n    \"stock\": 200\n  }\n# 用户索引\n{\n    \"id\": 1,\n    \"name\": \"电视机\",\n    \"category\": \"家电\",\n    \"price\": 599.99,\n    \"stock\": 50\n  },\n  {\n    \"id\": 2,\n    \"name\": \"手机\",\n    \"category\": \"电子设备\",\n    \"price\": 899.99,\n    \"stock\": 100\n  },\n  {\n    \"id\": 3,\n    \"name\": \"运动鞋\",\n    \"category\": \"服装\",\n    \"price\": 79.99,\n    \"stock\": 200\n  }\n# 订单索引\n{\n    \"order_id\": 1,\n    \"user_id\": 1,\n    \"products\": [\n      {\n        \"product_id\": 1,\n        \"quantity\": 2\n      },\n      {\n        \"product_id\": 2,\n        \"quantity\": 1\n      }\n    ],\n    \"total_price\": 2099.97,\n    \"order_date\": \"2023-12-10\",\n    \"shipping_address\": \"上海市\"\n  },\n  {\n    \"order_id\": 2,\n    \"user_id\": 3,\n    \"products\": [\n      {\n        \"product_id\": 3,\n        \"quantity\": 3\n      }\n    ],\n    \"total_price\": 239.97,\n    \"order_date\": \"2023-12-15\",\n    \"shipping_address\": \"广州市\"\n  },\n```\n\n因此，我们可以把索引当作是数据库中的表。\n\n\n\n数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有**映射（mapping）**，是索引中文档的字段约束信息，类似表的结构约束。\n\n\n\n### mysql 与 elasticsearch 一些概念的对比\n\n| **MySQL** | **Elasticsearch** | **说明**                                                     |\n| --------- | ----------------- | ------------------------------------------------------------ |\n| Table     | Index             | 索引(index)，就是文档的集合，类似数据库的表(table)           |\n| Row       | Document          | 文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式 |\n| Column    | Field             | 字段（Field），就是JSON文档中的字段，类似数据库中的列（Column） |\n| Schema    | Mapping           | Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema） |\n| SQL       | DSL               | DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD |\n\n是不是说，我们学习了elasticsearch就不再需要mysql了呢？\n\n并不是如此，两者各自有自己的擅长支出：\n\n- Mysql：擅长事务类型操作，可以确保数据的安全和一致性\n\n- Elasticsearch：擅长海量数据的搜索、分析、计算\n\n\n\n因此在企业中，往往是两者结合使用：\n\n- 对安全性要求较高的写操作，使用mysql实现\n- 对查询性能要求较高的搜索需求，使用elasticsearch实现\n- 两者再基于某种方式，实现数据的同步，保证一致性\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/lSn4Oaoe-image.png)\n\n\n## 安装\n\n关于安装的话，这里提供 Windows 版本，一个是elasticsearch、一个是 kibana （一个工具）。\n\n[安装参考](https://blog.csdn.net/Go_ahead_forever/article/details/133720298)\n\n### 安装中文分词器\n\nelasticsearch 对中文的分词不是很友好，一般的分词不管你选择的是标准分词器，还是中文分词器，结果都是只能分成一个一个的字，非常不友好。所以我们选择一个开源的分词器。[下载地址]([medcl/elasticsearch-analysis-ik: The IK Analysis plugin integrates Lucene IK analyzer into elasticsearch, support customized dictionary. (github.com)](https://github.com/medcl/elasticsearch-analysis-ik)) 你只需要把内容下载好，把这个目录解压放到安装 elasticsearch 的文件夹中的 plugins 目录中。例如：\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/HfG3Y3WF-image.png)\n\n\n\n放好以后，直接重启 elasticsearch 就好。\n\n如果出现报错说分词器版本不兼容 elasticsearch 只要进入下载好的分词器目录下面的 `plugin-descriptor.properties`文件中八版本改成和你的 elasticsearch 版本一致就好了。\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/hbBCNN9k-image.png)\n\n\n## 使用\n\n了解了上面的一些信息以后，我们接下来就开始使用 elasticsearch 吧。\n\n### 索引的增删改查\n\n索引库就类似数据库表，mapping映射就类似表的结构。\n\n我们要向es中存储数据，必须先创建“库”和“表”。\n\n#### mapping 映射属性\n\nmapping是对索引库中文档的约束，常见的mapping属性包括：\n\n- type：字段数据类型，常见的简单类型有：\n    - 字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）\n    - 数值：long、integer、short、byte、double、float、\n    - 布尔：boolean\n    - 日期：date\n    - 对象：object\n- index：是否创建索引，默认为true\n- analyzer：使用哪种分词器\n- properties：该字段的子字段\n\n\n\n例如：\n\n```json\n{\n    \"age\": 21,\n    \"weight\": 52.1,\n    \"isMarried\": false,\n    \"info\": \"created by xwhking\",\n    \"email\": \"2837468248@qq.com\",\n    \"score\": [99.1, 99.5, 98.9],\n    \"name\": {\n        \"firstName\": \"XWH\",\n        \"lastName\": \"Z\"\n    }\n}\n```\n\n对应的每个字段映射（mapping）：\n\n- age：类型为 integer；参与搜索，因此需要index为true；无需分词器\n- weight：类型为float；参与搜索，因此需要index为true；无需分词器\n- isMarried：类型为boolean；参与搜索，因此需要index为true；无需分词器\n- info：类型为字符串，需要分词，因此是text；参与搜索，因此需要index为true；分词器可以用ik_smart\n- email：类型为字符串，但是不需要分词，因此是keyword；不参与搜索，因此需要index为false；无需分词器\n- score：虽然是数组，但是我们只看元素的类型，类型为float；参与搜索，因此需要index为true；无需分词器\n- name：类型为object，需要定义多个子属性\n    - name.firstName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器\n    - name.lastName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器\n\n\n\n#### 创建索引库和映射\n\n##### 基本语法：\n\n- 请求方式： PUT\n- 请求路径：/{索引库名}， 可以自定义\n- 请求参数：mapping 映射\n\n格式：\n\n```json\nPUT /索引库名称\n{\n  \"mappings\": {\n    \"properties\": {\n      \"字段名\":{\n        \"type\": \"text\",\n        \"analyzer\": \"ik_smart\"\n      },\n      \"字段名2\":{\n        \"type\": \"keyword\",\n        \"index\": \"false\"\n      },\n      \"字段名3\":{\n        \"properties\": {\n          \"子字段\": {\n            \"type\": \"keyword\"\n          }\n        }\n      },\n      // ...略\n    }\n  }\n}\n```\n\n\n\n##### 示例（以上面的数据为例，我们所有的操作都在 Kibana 的中 dev tools 中完成）\n\n```json\nPUT /xwhking\n{\n  \"mappings\": {\n    \"properties\": {\n      \"age\":{\n        \"type\": \"integer\"\n      },\n      \"weight\" :{\n        \"type\": \"float\"\n      },\n      \"isMarrid\":{\n        \"type\": \"boolean\"\n      },\n      \"info\":{\n        \"type\": \"text\",\n        \"analyzer\": \"ik_smart\"\n      },\n      \"email\":{\n        \"type\": \"keyword\",\n        \"index\": false\n      },\n      \"score\" :{\n        \"type\": \"float\"\n      },\n      \"name\":{\n        \"properties\": {\n          \"firstname\":{\n            \"type\":\"keyword\" \n          },\n          \"lastname\" :{\n            \"type\":\"keyword\"\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n结果展示：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/pG0UVcXw-image.png)\n\n\n\n\n#### 查询索引库\n\n##### 基本语法：\n\n- 请求方式：GET\n- 请求路径：/索引库名\n- 请求参数：无\n\n格式：\n\n```json\nGET /索引库名\n```\n\n示例(上面创建的索引库)：\n\n```json\nGET /xwhking\n```\n\n结果展示：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/VNbUOXU6-image.png)\n\n\n\n#### 修改索引库\n\n倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库**一旦创建，无法修改mapping**。\n\n\n\n虽然无法修改mapping中已有的字段，但是却允许添加新的字段到mapping中，因为不会对倒排索引产生影响。\n\n##### 基本语法：\n\n- 请求方法：PUT\n- 请求路径：/索引库名/_mapping\n- 请求参数：properties （看下面的例子）\n\n格式：\n\n```json\nPUT /索引库名/_mapping\n{\n  \"properties\": {\n    \"新字段名\":{\n      \"type\": \"integer\"\n    }\n  }\n}\n```\n\n示例：\n\n为上面创建的索引添加一个 major 字段（Field）\n\n```json\n# 为索引添加字段\nPUT /xwhking/_mapping\n{\n  \"properties\" : {\n    \"major\" : {\n      \"type\" : \"keyword\"\n    }\n  }\n}\n```\n\n添加结果：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/ElbLOpkL-image.png)\n\n\n我们重新查看索引看是否有添加字段：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/rLksMtmY-image.png)\n\n\n从结果来看我们是成功了的。\n\n\n\n#### 删除索引库\n\n##### 基本语法：\n\n- 请求方式：DELETE\n- 请求路径：/索引库名\n- 请求参数： 无\n\n格式：\n\n```json\nDELETE /索引库名\n```\n\n例子：\n\n我们删除我们上面传创建的索引库，然后再去查询，看是否能够查询的到\n\n```\nDELETE /xwhking\n```\n\n结果：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/L9KpZHzb-image.png)\n\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/K7bpyVCI-image.png)\n\n\n很明显我们查询不到了。\n\n\n\n### 文档的增删改查\n\n#### 新增文档\n\n##### 基本语法：\n\n- 请求方式：POST\n- 请求路径：/索引库名/_doc/文档id   `注意这里的文档 id，如果不填，elasticsearch系统会自动帮你添加一个随机的 id 值`\n- 请求参数：一条以 `json` 为格式的数据采用键值对方式\n\n格式：\n\n```json\nPOST /索引库名/_doc/文档id\n{\n    \"字段1\": \"值1\",\n    \"字段2\": \"值2\",\n    \"字段3\": {\n        \"子属性1\": \"值3\",\n        \"子属性2\": \"值4\"\n    },\n    // ...\n}\n```\n\n例子：\n\n我们再把上面删除的索引重新创建一下，把最开始的那条数据插入试试\n\n```json\n# 创建一个文档\nPOST /xwhking/_doc/1\n{\n  \"age\":21,\n  \"weight\":52.1,\n  \"isMarried\":false,\n  \"info\":\"created by xwhking\",\n  \"email\":\"2837468248@qq.com\",\n  \"score\":[99.1, 99.5, 98.9], \n  \"name\":{\n      \"firstName\":\"XWH\",\n      \"lastName\":\"Z\"\n  }\n}\n```\n\n> 这里可能会有一个疑问：就是为什么我明明定义 score 的时候只是一个 float 类型，为什么在插入文档的时候就能插入一个数组呢？这是由 elasticsearch 决定的，因为elasticsearch 没有数组这个数据类型，所以就允许接受一个字段的多个值。\n\n结果：\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/zV7Abh9G-image.png)\n\n\n\n#### 查询文档\n\n##### 基本语法：\n\n- 请求方式：GET\n- 请求路径：/索引库名/_doc/文档id\n- 请求参数：无\n\n格式：\n\n```json\nGET /{索引库名称}/_doc/{id}\n```\n\n示例：\n\n```json\nGET /xwhking/_doc/1\n```\n\n结果：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/i9pL5AxI-image.png)\n\n\n\n\n#### 删除文档\n\n##### 基本语法：\n\n- 请求方式：DELETE\n- 请求路径：/索引库名/_doc/文档id\n- 请求参数：无\n\n格式：\n\n```json\nDELETE /{索引库名}/_doc/id值\n```\n\n示例\n\n```json\nDELETE /xwhking/_doc/1\n```\n\n结果参考\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/pZm9y2AG-image.png)\n\n\n\n\n#### 修改文档\n\n修改有两种方式：\n\n- 全量修改：直接覆盖原来的文档\n- 增量修改：修改文档中的部分字段\n\n\n\n##### 全量修改\n\n全量修改是覆盖原来的文档，其本质是：\n\n- 根据指定的id删除文档\n- 新增一个相同id的文档\n\n**注意**：如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了。\n\n###### 基本语法：\n\n- 请求方式：PUT\n- 请求路径：/索引库名/_doc/文档id\n- 请求参数：把所有文档信息要修改的进行修改，并且没有修改的也需要\n\n格式：\n\n```json\nPUT /{索引库名}/_doc/文档id\n{\n    \"字段1\": \"值1\",\n    \"字段2\": \"值2\",\n    // ... 略\n}\n```\n\n示例：\n\n我们改变一下上面文档的邮箱\n\n```json\nPUT /xwhking/_doc/1\n{\n    \"age\": 21,\n    \"weight\": 52.1,\n    \"isMarried\": false,\n    \"info\": \"created by xwhking\",\n    \"email\": \"https://www.github.com/xwhking\",\n    \"score\": [99.1, 99.5, 98.9],\n    \"name\": {\n        \"firstName\": \"XWH\",\n        \"lastName\": \"Z\"\n    }\n}\n```\n\n结果：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/7zdxE92A-image.png)\n\n\n\n##### 增量修改\n\n增量修改是只修改指定id匹配的文档中的部分字段。\n\n###### 基本语法：\n\n- 请求方式：POST\n- 请求路径：/索引库名/_update/文档id\n- 请求参数：doc 内容是要修改的字段，以及新的值\n\n基本格式：\n\n```json\nPOST /{索引库名}/_update/文档id\n{\n    \"doc\": {\n         \"字段名\": \"新的值\",\n    }\n}\n```\n\n示例（我们再把邮箱改回来）：\n\n```json\n# 修改文档，增量修改\nPOST /xwhking/_doc/1\n{\n  \"doc\": {\n    \"email\" : \"2837468248@qq..com\"\n  }\n}\n\n```\n\n其中的 version 表示修改次数，创建一次，上面一次全量修改一次，增量修改一次，所以是三次。\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/bS2PYjus-image.png)\n\n\n\n\n###  利用 RestAPI 在 Java 中使用 ElasticSearch\n\n这里暂不介绍如何使用，具体使用其实看一下官方文档，或者直接按照代码提示就可以做了，我们现在只要知道ElasticSearch原生的用法，再去用 Client 就很容易上手、理解。我们这里只稍微带一下在 Java 项目中如何引入。\n\n三步：\n\n1. 引入依赖\n\n    ```xml\n    <dependency>\n        <groupId>org.elasticsearch.client</groupId>\n        <artifactId>elasticsearch-rest-high-level-client</artifactId>\n    </dependency>\n    ```\n\n2. 因为 springboot 可能管理了 elasticsearch的版本，所以我们需要把这个版本依赖覆盖掉，并且改成我们自己 elasticsearch的版本\n\n    ```xml\n    <properties>\n        <java.version>1.8</java.version>\n        <elasticsearch.version>7.12.1</elasticsearch.version>\n    </properties>\n    ```\n\n3. 初始化 RestHighLevelClient\n\n    ```java\n    RestHighLevelClient client = new RestHighLevelClient(RestClient.builder(\n            HttpHost.create(\"http://192.168.150.101:9200\")\n    ));\n    ```\n\n\n\n\n> # TIPS\n>\n> Elasticsearch 中特殊的数据类型\n>\n> ES中支持两种地理坐标数据类型：\n>\n> - geo_point: 由纬度(latitude)和经度(longitude)确定的一个点。例如：\"32.8752345,120.2981576\"\n> - ge0_shape :有多个ge0_point组成的复杂几何图形。例如一条直线，\"LINESTRING(-77.0365338.897676,-77.00905138.889939)\"\n>\n> 字段拷贝可以使用copy to属性将当前字段拷贝到指定字段。示例：\n>\n> ```json\n> {\n>     \"a11\":{\n> \t\t\"type\":\"text\",\n> \t\t\"analyzer\":\"ik_max_word\"\n> \t},\n> \t\"brand\":{\n> \t\t\"type\":\"keyword\",\n> \t\t\"copy_to\":\"all\"\n>     }\n> }\n> ```\n>\n> \n\n\n\n### 如何搜索 ==> DSL查询文档\n\n#### 数组准备\n\n我这里直接开源一个数据初始化的代码，需要的话直接拉下来，然后通过看项目的 README 文件，配置 elasticsearch, 然后把数据放入elasticsearch 我们就开始进行搜索数据。\n\n[项目数据地址](https://github.com/xwhking/elasticsearch-test-data))\n\n\n\n#### DSL 查询分类\n\nElasticsearch提供了基于JSON的DSL（[Domain Specific Language](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html)）来定义查询。常见的查询类型包括：\n\n- **查询所有**：查询出所有数据，一般测试用。例如：match_all\n\n- **全文检索（full text）查询**：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：\n    - match_query\n    - multi_match_query\n- **精确查询**：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：\n    - ids\n    - range\n    - term\n- **地理（geo）查询**：根据经纬度查询。例如：\n    - geo_distance\n    - geo_bounding_box\n- **复合（compound）查询**：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：\n    - bool\n    - function_score\n\n\n\n##### 查询基本语法：\n\n- 请求方式： GET\n- 请求路径：/索引库/_search\n- 请求参数：根据不同请求方式不同\n\n\n\n基本格式：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"查询类型\": {\n      \"查询条件\": \"条件值\"\n    }\n  }\n}\n```\n\n\n\n示例查询所有：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match_all\": {\n    }\n  }\n}\n```\n\n结果：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/QAKYHo4S-image.png)\n\n\n\n#### 全文检索查询\n\n全文检索查询的基本流程如下：\n\n- 对用户搜索的内容做分词，得到词条\n- 根据词条去倒排索引库中匹配，得到文档id\n- 根据文档id找到文档，返回给用户\n\n比较常用的场景包括：\n\n- 商城的输入框搜索\n- 百度输入框搜索\n\n> #  TIPS\n>\n> 因为是拿着词条去匹配，因此参与搜索的字段也必须是可分词的text类型的字段。\n\n\n\n##### 基本语法\n\n- 请求方式： GET\n- 请求路径： /索引库/_search\n- 请求参数：\n    - match查询：单字段查询\n    - multi_match查询：多字段查询，任意一个字段符合条件就算符合查询条件\n\n###### 基本格式：\n\n**match 查询格式**\n\n```json\nGET /索引库名/_search\n{\n  \"query\": {\n    \"match\": {\n      \"FIELD\": \"TEXT\"\n    }\n  }\n}\n```\n\n**multi_match** 查询格式:\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"multi_match\": {\n      \"query\": \"TEXT\",\n      \"fields\": [\"FIELD1\", \" FIELD12\"]\n    }\n  }\n}\n```\n\n\n\n查询示例：\n\nmatch 示例：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match\": {\n      \"all\": \"希尔顿\"\n    }\n  }\n}\n```\n\nresult :\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/scDN9Kjk-image.png)\n\n\n\nmulti_match 示例：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"multi_match\": {\n      \"query\": \"如家\",\n      \"fields\": [\"brand\",\"name\"]\n    }\n  }\n}\n```\n\nresult:\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/X50sZ8fW-image.png)\n\n> # TIPS\n>\n> 如果这里我们使用同样的查询词，查询出来的结果会是一样的，为什么呢？\n>\n> 因为我们将brand、name、business值都利用copy_to复制到了all字段中。因此你根据三个字段搜索，和根据all字段搜索效果当然一样了。\n>\n> 但是，搜索字段越多，对查询性能影响越大，因此建议采用copy_to，然后单字段查询的方式。\n\n\n\n\n\n#### 精确查询\n\n精确查询一般是查找keyword、数值、日期、boolean等类型字段。所以**不会**对搜索条件分词。常见的有：\n\n- term：根据词条精确值查询\n- range：根据值的范围查询\n\n\n\n##### Term 查询\n\n因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是**不分词**的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。\n\n\n\n###### 基本语法\n\n- 请求方式： GET \n- 请求路径： /索引库/_search\n- 请求参数：见示例\n\n\n\n基本格式：\n\n```json\n// term查询\nGET /indexName/_search\n{\n  \"query\": {\n    \"term\": {\n      \"FIELD\": {\n        \"value\": \"VALUE\"\n      }\n    }\n  }\n}\n```\n\n示例：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"term\": {\n      \"city\": {\n        \"value\": \"上海\"\n      }\n    }\n  }\n}\n```\n\nresult:\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/tAfVTPMN-image.png)\n\n\n因为词条是精匹配如果我们输入的是`杭州上海`则不会有结果\n\n<u>但是，当我搜索的内容不是词条，而是多个词语形成的短语时，反而搜索不到：</u>\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/9ytTLAal-image.png)\n\n\n\n\n\n\n##### range 查询\n\n范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。\n\n\n\n###### 基本语法\n\n- 请求方式： GET\n- 请求路径： /索引库/_search\n- 请求参数:  看具体示例\n\n基本格式:\n\n```json\n// range查询\nGET /indexName/_search\n{\n  \"query\": {\n    \"range\": {\n      \"FIELD\": {\n        \"gte\": 10, // 这里的gte代表大于等于，gt则代表大于\n        \"lte\": 20 // lte代表小于等于，lt则代表小于\n      }\n    }\n  }\n}\n```\n\n示例:\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"range\": {\n      \"score\": {\n        \"gte\": 40,\n        \"lte\": 3000\n      }\n    }\n  }\n}\n```\n\nresult:\n\n出现的都是在 40 以上的！\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/HyuUk7Rf-image.png)\n\n\n#### \n\n\n\n#### 地理坐标查询\n\n所谓的地理坐标查询，其实就是根据经纬度查询，官方文档：https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html\n\n常见的使用场景包括：\n\n- 携程：搜索我附近的酒店\n- 滴滴：搜索我附近的出租车\n- 微信：搜索我附近的人\n\n##### 矩形范围查询\n\n###### 基本语法\n\n- 请求方式：GET\n- 请求路径：/索引库/_search\n- 请求参数：请看示例\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/LKTk6f8F-image.png)\n\n\n查询时，需要指定矩形的**左上**、**右下**两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。\n\n```json\n// geo_bounding_box查询\nGET /indexName/_search\n{\n  \"query\": {\n    \"geo_bounding_box\": {\n      \"FIELD\": {\n        \"top_left\": { // 左上点\n          \"lat\": 31.1,\n          \"lon\": 121.5\n        },\n        \"bottom_right\": { // 右下点\n          \"lat\": 30.9,\n          \"lon\": 121.7\n        }\n      }\n    }\n  }\n}\n```\n\n\n\n##### 附近查询\n\n附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。\n\n\n\n换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/AUdUXFoZ-image.png)\n\n\n\n###### 基本语法：\n\n- 请求方式：GET\n- 请求路径：/索引库/_search\n- 请求参数：请看示例\n\n格式：\n\n```json\n// geo_distance 查询\nGET /indexName/_search\n{\n  \"query\": {\n    \"geo_distance\": {\n      \"distance\": \"15km\", // 半径\n      \"FIELD\": \"31.21,121.5\" // 圆心\n    }\n  }\n}\n```\n\n示例：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"geo_distance\": {\n      \"distance\" : \"15km\",\n      \"location\" : \"31.21,121.5\"\n    }\n  }\n}\n```\n\nresult:\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/k4Ma09az-image.png)\n\n\n缩小一下半径（就是陆家嘴附近啦）：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/E8IwPGIW-image.png)\n\n\n\n\n\n\n#### 复合查询\n\n当我们利用match查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。\n\n例如，我们搜索 \"虹桥如家\"，结果如下：\n\n```json\n[\n  {\n    \"_score\" : 17.850193,\n    \"_source\" : {\n      \"name\" : \"虹桥如家酒店真不错\",\n    }\n  },\n  {\n    \"_score\" : 12.259849,\n    \"_source\" : {\n      \"name\" : \"外滩如家酒店真不错\",\n    }\n  },\n  {\n    \"_score\" : 11.91091,\n    \"_source\" : {\n      \"name\" : \"迪士尼如家酒店真不错\",\n    }\n  }\n]\n```\n\n在elasticsearch中，早期使用的打分算法是TF-IDF算法，公式如下：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/Momoc6Lm-image.png)\n\n\n在后来的5.1版本升级中，elasticsearch将算法改进为BM25算法，公式如下：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/hTMPbBia-image.png)\n\nTF-IDF算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而BM25则会让单个词条的算分有一个上限，曲线更加平滑：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/QpDICwJw-image.png)\n\n\n\n##### 算分函数查询\n\n根据相关度打分是比较合理的需求，但**合理的不一定是产品经理需要**的。\n\n以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。\n\n要想认为控制相关性算分，就需要利用elasticsearch中的function score 查询了。\n\n###### 基本语法：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/esYOtDN1-image.png)\n\n\nfunction score 查询中包含四部分内容：\n\n- **原始查询**条件：query部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，**原始算分**（query score)\n- **过滤条件**：filter部分，符合该条件的文档才会重新算分\n- **算分函数**：符合filter条件的文档要根据这个函数做运算，得到的**函数算分**（function score），有四种函数\n    - weight：函数结果是常量\n    - field_value_factor：以文档中的某个字段值作为函数结果\n    - random_score：以随机数作为函数结果\n    - script_score：自定义算分函数算法\n- **运算模式**：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：\n    - multiply：相乘\n    - replace：用function score替换query score\n    - 其它，例如：sum、avg、max、min\n\n\n\nfunction score的运行流程如下：\n\n- 1）根据**原始条件**查询搜索文档，并且计算相关性算分，称为**原始算分**（query score）\n- 2）根据**过滤条件**，过滤文档\n- 3）符合**过滤条件**的文档，基于**算分函数**运算，得到**函数算分**（function score）\n- 4）将**原始算分**（query score）和**函数算分**（function score）基于**运算模式**做运算，得到最终结果，作为相关性算分。\n\n\n\n因此，其中的关键点是：\n\n- 过滤条件：决定哪些文档的算分被修改\n- 算分函数：决定函数算分的算法\n- 运算模式：决定最终算分结果\n\n\n\n示例：\n\n需求：给“如家”这个品牌的酒店排名靠前一些\n\n翻译一下这个需求，转换为之前说的四个要点：\n\n- 原始条件：不确定，可以任意变化\n- 过滤条件：brand = \"如家\"\n- 算分函数：可以简单粗暴，直接给固定的算分结果，weight\n- 运算模式：比如求和\n\n因此最终的DSL语句如下：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"function_score\": {\n      \"query\": {\n        \"match\": {\n          \"all\": \"外滩\"\n        }\n      },\n      \"functions\": [\n        {\n          \"filter\": {\n            \"term\": {\n              \"brand\": \"如家\"\n            }\n          },\n          \"weight\": 100\n        }\n      ],\n      \"boost_mode\": \"sum\"\n    }\n  }\n}\n```\n\nresult:\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/fi0Snwmi-image.png)\n\n\n\n\nfunction score query定义的三要素是什么？\n\n- 过滤条件：哪些文档要加分\n- 算分函数：如何计算function score\n- 加权方式：function score 与 query score如何运算\n\n\n\n##### 布尔查询\n\n布尔查询是一个或多个查询子句的组合，每一个子句就是一个**子查询**。子查询的组合方式有：\n\n- must：必须匹配每个子查询，类似“与”\n- should：选择性匹配子查询，类似“或”\n- must_not：必须不匹配，**不参与算分**，类似“非”\n- filter：必须匹配，**不参与算分**\n\n\n\n比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤：\n\n每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用bool查询了。\n\n\n\n需要注意的是，搜索时，参与**打分的字段越多，查询的性能也越差**。因此这种多条件查询时，建议这样做：\n\n- 搜索框的关键字搜索，是全文检索查询，使用must查询，参与算分\n- 其它过滤条件，采用filter查询。不参与算分\n\n\n\n###### 基本语法\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        {\"term\": {\"city\": \"上海\" }}\n      ],\n      \"should\": [\n        {\"term\": {\"brand\": \"皇冠假日\" }},\n        {\"term\": {\"brand\": \"华美达\" }}\n      ],\n      \"must_not\": [\n        { \"range\": { \"price\": { \"lte\": 500 } }}\n      ],\n      \"filter\": [\n        { \"range\": {\"score\": { \"gte\": 45 } }}\n      ]\n    }\n  }\n}\n```\n\n\n\n示例：\n\n需求：搜索名字包含“如家”，价格不高于400，在坐标31.21,121.5周围10km范围内的酒店。\n\n分析：\n\n- 名称搜索，属于全文检索查询，应该参与算分。放到must中\n- 价格不高于400，用range查询，属于过滤条件，不参与算分。放到must_not中\n- 周围10km范围内，用geo_distance查询，属于过滤条件，不参与算分。放到filter中\n\nresult：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1645799822881509377/3rDBVhLM-image.png)\n\n\n\n#### 搜索结果处理\n\n##### 排序\n\n地理坐标排序略有不同。\n\n**语法说明**：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"sort\": [\n    {\n      \"_geo_distance\" : {\n          \"FIELD\" : \"纬度，经度\", // 文档中geo_point类型的字段名、目标坐标点\n          \"order\" : \"asc\", // 排序方式\n          \"unit\" : \"km\" // 排序的距离单位\n      }\n    }\n  ]\n}\n```\n\n这个查询的含义是：\n\n- 指定一个坐标，作为目标点\n- 计算每一个文档中，指定字段（必须是geo_point类型）的坐标 到目标点的距离是多少\n- 根据距离排序\n\n\n\n##### 分页\n\nelasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。elasticsearch中通过修改from、size参数来控制要返回的分页结果：\n\n- from：从第几个文档开始\n- size：总共查询几个文档\n\n类似于mysql中的`limit ?, ?`\n\n\n\n分页的基本语法如下：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"from\": 0, // 分页开始的位置，默认为0\n  \"size\": 10, // 期望获取的文档总数\n  \"sort\": [\n    {\"price\": \"asc\"}\n  ]\n}\n```\n\n\n\n现在，我要查询990~1000的数据，查询逻辑要这么写：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"from\": 990, // 分页开始的位置，默认为0\n  \"size\": 10, // 期望获取的文档总数\n  \"sort\": [\n    {\"price\": \"asc\"}\n  ]\n}\n```\n\n这里是查询990开始的数据，也就是 第990~第1000条 数据。\n\n不过，elasticsearch内部分页时，必须先查询 0~1000条，然后截取其中的990 ~ 1000的这10条：\n\n查询TOP1000，如果es是单点模式，这并无太大影响。\n\n但是elasticsearch将来一定是集群，例如我集群有5个节点，我要查询TOP1000的数据，并不是每个节点查询200条就可以了。\n\n因为节点A的TOP200，在另一个节点可能排到10000名以外了。\n\n因此要想获取整个集群的TOP1000，必须先查询出每个节点的TOP1000，汇总结果后，重新排名，重新截取TOP1000。\n\n那如果我要查询9900~10000的数据呢？是不是要先查询TOP10000呢？那每个节点都要查询10000条？汇总到内存中？\n\n\n\n当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此elasticsearch会禁止from+ size 超过10000的请求。\n\n针对深度分页，ES提供了两种解决方案，[官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html)：\n\n- search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。\n- scroll：原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。\n\n\n\n\n\n##### 高亮\n\n高亮显示的实现分为两步：\n\n- 1）给文档中的所有关键字都添加一个标签，例如`<em>`标签\n- 2）页面给`<em>`标签编写CSS样式\n\n**高亮的语法**：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match\": {\n      \"FIELD\": \"TEXT\" // 查询条件，高亮一定要使用全文检索查询\n    }\n  },\n  \"highlight\": {\n    \"fields\": { // 指定要高亮的字段\n      \"FIELD\": {\n        \"pre_tags\": \"<em>\",  // 用来标记高亮字段的前置标签\n        \"post_tags\": \"</em>\" // 用来标记高亮字段的后置标签\n      }\n    }\n  }\n}\n```\n\n\n\n**注意：**\n\n- 高亮是对关键字高亮，因此**搜索条件必须带有关键字**，而不能是范围这样的查询。\n- 默认情况下，**高亮的字段，必须与搜索指定的字段一致**，否则无法高亮\n- 如果要对非搜索字段高亮，则需要添加一个属性：required_field_match=false\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 2,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1645799822881509377",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-23T13:09:30.000+00:00",
        "updateTime": "2023-12-23T16:05:18.000+00:00",
        "user": {
          "id": "1645799822881509377",
          "planetCode": "14255",
          "userName": "无名",
          "userAvatar": null,
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-04-11T06:21:49.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-04-11T14:43:49.000+00:00",
          "updateTime": "2023-11-30T13:29:27.000+00:00"
        },
        "tags": [
          "文章",
          "Elasticsearch",
          "Java"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1738163145303678977",
        "title": "几分钟，教你搭个 AI 绘画平台~",
        "description": null,
        "content": "大家好，我是程序员鱼皮。\n\nAI 绘画是 23 年最火的技术之一。对程序员来说，以前我们想做个网站，会经常因为没有图片素材而发愁；而现在用 AI 绘画技术，想要什么图片，**只要输入文字就能快速生成了**。\n\n比如我们公司官网的主图，就是用 AI 绘画生成的，效果非常惊艳！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1702031098464-c2d015f3-4241-4422-85cc-7aeee2eafdc8.png)\n\n\n\n设计师：我失业了？\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1702031170366-70ac7506-fff5-4a0a-9641-28268c7cd92d.png)\n\n\n\n当然，设计师有了 AI 绘画，更是如虎添翼，可以给自己增加无穷的灵感，比如让小猫咪敲代码：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1702031355547-919342a5-4f0b-4f1e-bd27-55ad3cc8ecad.png)\n\n\n\n那么问题来了，这么牛的 AI 绘画技术，我们如何使用呢？\n\n我们肯定需要一个强大的 AI 绘画工具。目前主流的 AI 绘画工具有 Stable Diffusion、DreamStudio、Midjourney、DALL·E2 等，这里鱼皮推荐大家选择当前较火的 **开源工具** Stable Diffusion，比起使用其他开发者封装的平台，可以更灵活、定制化地生成图像。\n\n\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1702034102121-b8861d53-d08d-44d3-bd39-a29140ca7e4a.png)\n\n\n\n那么如何使用 Stable Diffusion 呢？\n\n其实非常简单！这篇文章是一个保姆级教程，我就教大家用最简单易学的方式，快速搭建一个属于自己的 Stable Diffusion AI 绘画工具，没有限制，想画什么就能画什么。。。\n\n\n\n## 使用教程\n\n### 一、选择环境\n\nStable Diffusion 本质上是一套开源的代码，既然是代码，就得想办法部署运行。\n\n我们可以用自己的电脑部署。但是，Stable Diffusion 对硬件是有要求的：不少于 16 GB 内存，并且拥有 60 GB 以上的硬盘空间，需要用到 CUDA 架构，推荐使用 N 卡等等。\n\n虽然目前已经有了对 A 卡的相关支持，但运算的速度明显慢于 N 卡。\n\n\n\n结果我一看自己电脑的配置，发现算力根本不够啊！直接倒在了第一步。。。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701927245080-35af807d-2fd5-4778-9a94-ee3a4a74bf43.png)\n\n\n\n没关系，自己的电脑不行，我们可以搞一个 GPU 云服务器，来部署 Stable Diffusion。\n\n有了云服务器后，我们通常还需要自己安装各种依赖软件，以支持 Stable Diffusion 的部署。对于不熟悉 Linux 的同学来说，这其实是很麻烦的一件事。\n\n有没有什么云服务器，可以直接帮我们装好 Stable Diffusion 呢？让我们可以直接使用。\n\n当然有，大厂自然能考虑到这个痛点。比如腾讯云最近新出了一个高性能应用服务 `HAI`，是一款面向 AI 和科学计算的 GPU 应用服务，提供了即插即用的算力和常用的 AI 环境。\n\n官方：https://cloud.tencent.com/product/hai\n\n\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1702637467627-8968eb33-5968-4f39-8e77-d21b7d850ba4.png)\n\n\n\nHAI 提供了很多预装的模型，能够一键部署常用的 AI 应用环境，比如本文主讲的 Stable Diffusion、LLM 等；还提供了 Python 开发者常用的 JupyterLab 等可视化界面。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1702637628239-f7830465-bf9d-4d6c-ae28-a96722071b68.png)\n\n\n\n简单来说，HAI = GPU 服务器 + 开箱即用的应用，就像一台给你安装好了各种软件的电脑，拿来就能使用了~\n\n\n\n腾讯云的 HAI 不仅可以预装 Stable Diffusion，还可以选择其它 AI 模型，例如 ChatGLM2 6B、Llama2 7B、Llama 13B 等，对 AI 应用开发者会很有帮助。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1702016574157-7a9d4614-163e-4c1a-9cdb-bac8cc0cf22a.png)\n\n\n\n还可以预装 AI 框架，比如 Pytorch2.0.0、Tensorflow2.9.0 等：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701941737719-b7da3a3d-bb22-4047-82bd-5df944fe5059.png)\n\n\n\n那既然我们选好了开发环境，下一步就可以开始部署 AI 绘画平台啦~\n\n\n\n### 二、安装 Stable Diffusion\n\n首先从腾讯云 HAI 官网进入算力管理页面，点击 `新建` 按钮，新增一台服务器。\n\n指路：https://console.cloud.tencent.com/hai/instance\n\n\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1702637771561-e6f0e680-a705-4930-910f-067d8da2efc4.png)\n\n\n\n然后选择服务器的规格。其实这里只要设置一下实例名称，其余保持默认就好：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1702637825763-c5c19733-4566-4208-a322-d32efee07989.png)\n\n\n\n然后等待创建：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701743254929-e414b354-1ca8-4f81-af4b-564ab69a323e.png)\n\n\n\n创建的过程中，可以进行加速设置，选择你创建的地域即可免费加速：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701745722857-63811e53-480b-4317-9e34-3441695462e6.png)\n\n\n\n大概几分钟左右，GPU 服务器就创建完毕啦，可以看到 HAI 正在运行中：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701745869649-dcd260fc-9c17-46aa-b5ff-e11609e5b2fb.png)\n\n\n\n然后点击算力连接，可以看到 `Gradio WebUI`，这是 HAI 服务器帮我们安装好的 Stable Diffusion 使用界面：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701850588229-7f31ecf3-5fdf-4625-ae9b-4f1b007b66d9.png)\n\n\n\n打开它，就能够愉快地使用 AI 绘画啦~ 就这么简单！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701850664510-3dba50a3-a998-4c3f-8287-b832ea14d266.png)\n\n\n\n### 三、使用 AI 绘画\n\nAI 绘画是一门学问，要想画出最理想的图片，就要认真编写 `prompt`，也就是输入给 AI 的文字。\n\n如果你不知道怎么写 prompt，也很简单，可以直接从 `Civitai` 网站中选择一个好看的图片并直接获取到现成的 prompt。\n\n比如这里我选一只猫：\n\n示例图片：https://civitai.com/images/4121406\n\n\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701850856934-9b88c8a3-a639-4ac5-ad14-752adba0bab0.png)\n\n\n\n当然，也可以选择别的图（我知道你们想选什么，别想了）：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1702033263150-b41779c4-a28c-489c-ab38-31a8b0b550dd.png)\n\n\n\n言归正传。我们从上述网站中复制图片的 prompt 以及 Negative prompt，并粘贴到 Stable Diffusion 平台：\n\nNegative prompt：用户指定模型在图像生成过程中应该避免的提示，例如畸形手脚、低画质等\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701848995088-5de3d3a8-4834-4fe4-b9c9-4df5cb3627a2.png)\n\n\n\n还可以在 Stable Diffusion 平台设置一些其他的参数，来优化生成的效果，比如 Sampling method、Sampling steps、CFG Scale、Seed 等，这些都可以从上面的网站复制，或者自己调试。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701849025642-c4aeafff-5a85-455d-a6f5-f044d882fded.png)\n\n\n\n点击 Generate，然后等待十几秒，就能看到效果了：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1702034462861-e715073d-1f9d-44ed-b28b-7ff80f90c0e7.png)\n\n\n\n诶，出来了！猫出来了！\n\n虽然猫是画出来了，但大家仔细一看就会发现，这只猫有点奇怪啊！尤其是腿和尾巴，这只猫放到 2023 年显得有点过于先进了。\n\n这是因为 Stable Diffusion 内置的基础模型能力一般，答应我，千万别画人！我怕你晚上睡不着觉。。。\n\n为了让图像更加真实美观，我们可以在 Civitai 找个更专业的动物模型来优化生成的图像。\n\n\n\n### 四、使用模型优化图像\n\n首先从 Civitai 网站中下载模型：\n\n指路：https://civitai.com/models\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701847873040-e827f714-ae2e-4605-8bdb-e4ce4da8abf0.png)\n\n\n\n这里我选择的是包含 `ANIMAL` 标签中的第一个，如下图：\n\n指路：https://civitai.com/models/122793/fenrisxl\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701847910226-e1c17fe5-5290-4e18-a0fb-dd9cb4e69d50.png)\n\n\n\n点击右侧下载模型：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701847931637-0445f750-de15-419a-beba-22efa1d9cf47.png)\n\n\n\n下载完毕后可以通过一个牛 X 的 SD 法术解析网站来查看下载的模型信息和用法：\n\n指路：https://spell.novelai.dev/\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701842563892-6cefb6f1-8158-4b8e-9061-3abbdaa6b83a.png)\n\n\n\n可以按照模型用法的指示将 model 文件放到对应的文件夹中。\n\n有个问题，怎么把模型文件放到咱的服务器上呢？\n\n其实 HAI 在新建成功后，就会自动帮我们安装 `JupyterLab`，一个基于 Web 的开源交互式开发环境，可以直接在网页上运行 Python 代码、执行终端命令来操作服务器、管理文件等。\n\n直接在 HAI 控制台打开 JupyterLab：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701745912580-52e6a456-1a9f-4047-a60d-9b31c2132b48.png)\n\n\n\n进入 JupyterLab 的界面：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701746335730-f6790bac-c940-45fb-82bd-f86531f29628.png)\n\n\n\n通过 JupyterLab，我们可以很方便地进入到 `/root/stable-diffusion-webui/models/Stable-diffusion` 目录下：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701842729217-5356584e-0593-4dc1-9389-d0c871541be3.png)\n\n\n\n然后点击上传，将下载好的模型文件上传到服务器上：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701842787580-88c9b71b-8204-4fdf-bddf-fabdff636a4d.png)\n\n\n\n此时会在后台默默上传，建议不要关闭当前的 JupyterLab 页面，可在 JupyterLab 下方查看文件上传进度：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701849947361-9cf685b3-cb75-4c9f-8b92-69ee542f6c06.png)\n\n\n\n然后进入 Gradio WebUI，此时可以在左上角选择我们刚刚下载的模型：\n\n记得先点击下刷新按钮\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701852338596-4b797949-5c20-4fb4-8a38-60f2aa831863.png)\n\n\n\n切换好模型后，再次点击 Generate 生成，这次生成的效果图：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1701852447872-3ddd1c16-c3f7-423d-9e45-dee57f476fae.png)\n\n先看整体，嗯，不错！\n\n再看细节，瞳孔、前爪、后腿都没问题。甚至还给我多了一部分背景，nice~\n\n\n\n## 最后\n\n以上就是本期 AI 绘画教程，总结一下，我们能这么快、不写代码地搭建 AI 绘画平台，得益于 Stable Diffusion 的开源以及腾讯云 HAI 的能力，开箱即用真的是太爽了。\n\n腾讯云 HAI 的价格是 1.2 元 / 小时。这里鱼皮分享个省钱小技巧 —— 用完就关！就很实惠了~\n\n注意，如果你的硬盘选择了默认的 80 GB 容量，那么在创建的 15 天内是可以实现关机免计费的，15天后关机也只需要 0.02 元 / 小时。\n\n\n\n访问网站 https://cloud.tencent.com/product/hai 就可以使用腾讯云 HAI 啦~\n\n学会的同学，点个赞支持一下吧，感谢！\n\n\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1702035035700-274db9cb-1092-41a8-a185-d9359aa80401.png)",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/u9O8osxt-640.png",
        "language": null,
        "viewNum": 14,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-22T11:42:42.000+00:00",
        "updateTime": "2023-12-23T12:58:03.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 3005,
          "coin": 170,
          "followeeNum": 1297,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2024-05-24T03:35:38.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-12-22T23:17:31.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1737341374748975105",
        "title": "TextCNN文本分类模型在文章评论审核中的实现与部署",
        "description": "网络上的\"喷子\"现象导致新闻文章评论区充斥着大量谩骂言辞。为了提升平台品质和用户体验，急需解决如何自动拦截这些谩骂评论的问题。本文旨在通过构建卷积神经网络模型，实现对谩骂评论的自动识别，以机器方式对抗这些网络喷子。",
        "content": "# 三、文章评论审核TextCnn文本分类模型实现和部署\n\n网络上的\"喷子\"现象导致新闻文章评论区充斥着大量谩骂言辞。为了提升平台品质和用户体验，急需解决如何自动拦截这些谩骂评论的问题。本文旨在通过构建卷积神经网络模型，实现对谩骂评论的自动识别，以机器方式对抗这些网络喷子。\n\n在新闻文章评论中，经常可见包括对新闻人物的辱骂、对编辑的恶语以及评论回复中对楼主的攻击等谩骂言辞，这不仅损害了平台的声誉和品质，更直接影响了用户的使用体验。因此，减少谩骂评论的出现成为迫切需要解决的问题。鉴于评论数量庞大，仅依赖人工审核显然是不切实际的。我们的目标是建立一种自动识别算法，通过模型拦截这些脏话脏语，从而有效净化评论区。\n\n## 1. 算法结构和思路\n\n![WXKcJ.png](https://i.imgs.ovh/2023/12/20/WXKcJ.png)\n\n1.  **预处理阶段**： \n\n- - **文本清洗**：去除无关字符、标点符号，统一大小写等，以规范输入文本。\n  - **分词处理**：将文本划分为词汇，有助于更精准地进行后续检测。\n\n2.  **辱骂违规词检测**： \n\n- - **建立违规词库**：维护一个包含辱骂和不当言辞的词汇库，定期更新以适应新的网络用语。\n  - **多层次匹配**：采用多层次的匹配策略，包括精确匹配、模糊匹配和同义词匹配，提高检测的准确性。\n  - **动态过滤**：考虑引入动态过滤机制，即根据用户行为和社交网络动态，调整违规词库，使其更符合实际使用情境。\n\n3.  **政治敏感词检测**： \n\n- - **建立敏感词库**：创建一个包含政治敏感词汇的库，以便检测涉及政治敏感话题的评论。\n  - **关联性分析**：考虑评论中词汇的关联性，以防止误判。某些词汇可能在特定上下文中并非政治敏感，因此需要综合考虑。\n\n4.  **TextCNN模型**： \n\n- - **模型架构**：确保TextCNN模型具有合适的深度和广度，以捕捉评论中的语义和上下文信息。\n  - **多通道卷积**：考虑使用多个卷积核和多通道的卷积层，以捕获不同尺度的特征。\n\n5.  **输出和审核结果**： \n\n- - **综合判断**：融合辱骂违规词检测、政治敏感词检测和TextCNN模型的输出，形成最终的审核决策。\n  - **可解释性**：为了提高模型的可解释性，记录各个阶段的判断结果，以便后续调整和分析。\n\n**总结逻辑设计的好处**：\n\n-  **多层次策略**：通过多层次的违规词检测和模型判断，提高了对违规评论的综合判断能力。 \n-  **实时适应性**：动态过滤机制和动态更新词库能够使模型更好地适应不断变化的网络用语和社交动态。 \n-  **综合性能**：综合利用违规词检测和深度学习模型，既考虑了明显的违规用语，也能够处理语义和上下文信息。 \n-  **可解释性**：记录各个阶段的判断结果，有助于理解模型的决策过程，方便进一步优化和维护。 \n\n通过这样细致和综合的设计，可以提高评论审核模型的准确性和鲁棒性，更好地满足实际需求。\n\n## 2. 数据来源\n\n- 参考文章：https://cloud.tencent.com/developer/article/1068648\n- 数据来源：https://github.com/wjx-git/IllegalTextDetection\n\n## 3. 模型选择\n\n### 3.1. 结构\n\n以下是TextCNN模型的结构图，结构简单，即使在CPU也能训练：\n\n```yaml\nInput: 文本序列 (batch, sentence_length)\n\n       |\n       V\n\nEmbedding层:  (batch, sentence_length, embed_dim)\n\n       |  \\\n       V   V\n\nConv2D + ReLU + MaxPool: (batch, kernel_num)   (conv11)\n       |\n       V\n\nConv2D + ReLU + MaxPool: (batch, kernel_num)   (conv12)\n       |\n       V\n\nConv2D + ReLU + MaxPool: (batch, kernel_num)   (conv13)\n       |\n       V\n\n       |      |      |\n       V      V      V\n\nConcatenate: (batch, 3 * kernel_num)\n\n       |\n       V\n\nDropout层: (batch, 3 * kernel_num)\n\n       |\n       V\n\n全连接层: 输出 (batch, class_num)\n```\n\n### 3.2. 分层解析\n\n1.  **Embedding层**： \n\n- - **作用**：将输入的文本序列中的每个词汇映射为对应的词向量，提供词汇的语义信息。\n\n2.  **Conv2D + ReLU + MaxPool**（conv11、conv12、conv13，三个相同结构的层）： \n\n- - **作用**：这三个层组成了多个不同尺寸的卷积核，用于捕捉输入文本中不同尺度的语义特征。\n  - **Conv2D**：卷积操作用于检测输入文本中的局部模式。\n  - **ReLU**：激活函数引入非线性，增强模型表达能力。\n  - **MaxPool**：最大池化操作用于降维，保留最显著的特征。\n\n3.  **Concatenate**： \n\n- - **作用**：将三个卷积核得到的不同尺度的特征连接在一起，使模型能够同时考虑多个尺度的语义信息。\n\n4.  **Dropout层**： \n\n- - **作用**：在训练过程中随机丢弃部分神经元，减少过拟合的风险。\n\n5.  **全连接层**： \n\n- - **作用**：将连接后的特征映射到最终的输出类别空间，用于文本分类任务。\n\n这个textCNN模型通过嵌入层、卷积层、全连接层等组件，能够有效地捕捉输入文本的语义信息，并用于文本分类。\n\n### 3.3. 关于嵌入层\n\n当我们使用嵌入层时，我们将每个单词的索引映射为一个词向量。让我们假设我们有一个词汇表，其中包含5个单词：['I', 'love', 'natural', 'language', 'processing']，并且我们选择一个嵌入维度 `embed_dim` 为 4。\n\n\n\n如果我们的输入文本是 \"I love language\"，我们可以将它表示为索引序列 [0, 1, 3]，其中 \"I\" 的索引是 0，\"love\" 的索引是 1，\"language\" 的索引是 3。\n\n\n\n通过嵌入层，我们可以将这些索引映射为词向量。假设我们的嵌入层参数是随机初始化的，那么可能的映射如下：\n\n\n\n```plain\nEmbedding Matrix:\n[[ 0.1,  0.2,  0.3,  0.4],  # 对应 \"I\"\n [ 0.5,  0.6,  0.7,  0.8],  # 对应 \"love\"\n [ 0.9,  1.0,  1.1,  1.2],  # 对应 \"natural\"\n [ 1.3,  1.4,  1.5,  1.6],  # 对应 \"language\"\n [ 1.7,  1.8,  1.9,  2.0]]  # 对应 \"processing\"\n\n输入序列 [0, 1, 3] 对应的词向量：\n[[ 0.1,  0.2,  0.3,  0.4],  # 对应 \"I\"\n [ 0.5,  0.6,  0.7,  0.8],  # 对应 \"love\"\n [ 1.3,  1.4,  1.5,  1.6]]  # 对应 \"language\"\n```\n\n\n\n这就是嵌入层的作用：将文本中的单词索引映射为对应的词向量。这些词向量将成为模型的输入，帮助模型理解文本中的语义信息。在训练的过程中，这些嵌入矩阵的权重会被学习，以更好地适应具体的任务。\n\n在文本处理中，原始的单词索引是一维的，通过嵌入操作，我们将这一维的离散索引映射为连续的词向量，从而引入了更多的语义信息。嵌入操作将原始的离散表示转换成密集的连续表示，这样模型可以更好地理解词汇之间的语义关系。\n\n嵌入的维度（`embed_dim`）通常是一个超参数，可以根据任务和数据集的性质进行调整。较大的嵌入维度能够提供更丰富的语义信息，但也需要更多的计算资源和数据来进行训练。\n\n\n\n## 4. 数据处理\n\n本文的数据处理过程涵盖以下主要步骤：\n\n1. 通过对原始数据集 `train.txt` 进行处理，生成词表 `word_list.txt`。为了提升词表的容量，我们并未设定单词阈值，而是完全将所有单词纳入词表中。\n\n![WX7d3.png](https://i.imgs.ovh/2023/12/20/WX7d3.png)\n\n2. 利用生成的词表 `word_list.txt`，将 `train.txt`、`dev.txt` 和 `test.txt` 转换为相应的单词索引向量。\n\n![WXQ29.png](https://i.imgs.ovh/2023/12/20/WXQ29.png)\n## 5. 模型训练和验证\n\n### 5.1. 代码文件\n\n![WXt6o.png](https://i.imgs.ovh/2023/12/20/WXt6o.png)\n\n### 5.2. 训练环境\n\n采用Python3.9，conda环境，\n\n可手动安装以下依赖（不写版本号默认最新版）其余依赖应该会自动装好，如果没有，按需安装即可：\n\n1. pytorch（从官方下载自己设备适配的版本即可）\n2. jieba\n3. nltk\n4. pandas\n5. re（Python自带）\n6. tqdm\n7. numpy\n8. flask\n9. flask_cors\n10. gunicorn（处理高并发的服务器，云部署时用）\n\n所有依赖包信息如下：\n\n> Package                  Version\n>\n> ------------------------ -----------\n>\n> anyio                    3.6.2\n>\n> argon2-cffi              21.3.0\n>\n> argon2-cffi-bindings     21.2.0\n>\n> asttokens                2.2.1\n>\n> attrs                    22.2.0\n>\n> backcall                 0.2.0\n>\n> beautifulsoup4           4.11.1\n>\n> bleach                   6.0.0\n>\n> blinker                  1.7.0\n>\n> bs4                      0.0.1\n>\n> certifi                  2022.12.7\n>\n> cffi                     1.15.1\n>\n> chardet                  4.0.0\n>\n> charset-normalizer       3.0.1\n>\n> click                    8.1.7\n>\n> cloudpickle              2.2.1\n>\n> colorama                 0.4.6\n>\n> comm                     0.1.2\n>\n> contourpy                1.0.5\n>\n> cycler                   0.11.0\n>\n> d2l                      0.17.6\n>\n> debugpy                  1.6.6\n>\n> decorator                5.1.1\n>\n> defusedxml               0.7.1\n>\n> et-xmlfile               1.1.0\n>\n> executing                1.2.0\n>\n> filelock                 3.13.1\n>\n> Flask                    3.0.0\n>\n> Flask-Cors               4.0.0\n>\n> fonttools                4.37.4\n>\n> fsspec                   2023.12.2\n>\n> idna                     2.10\n>\n> imageio                  2.26.0\n>\n> importlib-metadata       6.0.0\n>\n> ipykernel                6.20.2\n>\n> ipython                  8.8.0\n>\n> ipython-genutils         0.2.0\n>\n> ipywidgets               8.0.4\n>\n> itsdangerous             2.1.2\n>\n> jdcal                    1.4.1\n>\n> jedi                     0.18.2\n>\n> jieba                    0.42.1\n>\n> Jinja2                   3.1.2\n>\n> joblib                   1.3.2\n>\n> jsonschema               4.17.3\n>\n> jupyter                  1.0.0\n>\n> jupyter_client           8.0.1\n>\n> jupyter-console          6.4.4\n>\n> jupyter_core             5.1.5\n>\n> jupyter-events           0.6.3\n>\n> jupyter_server           2.1.0\n>\n> jupyter_server_terminals 0.4.4\n>\n> jupyterlab-pygments      0.2.2\n>\n> jupyterlab-widgets       3.0.5\n>\n> kiwisolver               1.4.4\n>\n> lazy_loader              0.1\n>\n> MarkupSafe               2.1.2\n>\n> matplotlib               3.5.1\n>\n> matplotlib-inline        0.1.6\n>\n> mistune                  2.0.4\n>\n> mpmath                   1.3.0\n>\n> nbclassic                0.5.1\n>\n> nbclient                 0.7.2\n>\n> nbconvert                7.2.9\n>\n> nbformat                 5.7.3\n>\n> nest-asyncio             1.5.6\n>\n> networkx                 3.2.1\n>\n> nltk                     3.8.1\n>\n> notebook                 6.5.2\n>\n> notebook_shim            0.2.2\n>\n> numpy                    1.26.2\n>\n> openpyxl                 3.2.0b1\n>\n> packaging                21.3\n>\n> pandas                   2.1.4\n>\n> pandocfilters            1.5.0\n>\n> parso                    0.8.3\n>\n> pickleshare              0.7.5\n>\n> Pillow                   9.2.0\n>\n> pip                      23.3.1\n>\n> platformdirs             2.6.2\n>\n> prometheus-client        0.16.0\n>\n> prompt-toolkit           3.0.36\n>\n> psutil                   5.9.4\n>\n> psycopg2                 2.9.6\n>\n> pure-eval                0.2.2\n>\n> pycparser                2.21\n>\n> pygad                    2.19.2\n>\n> Pygments                 2.14.0\n>\n> pyparsing                3.0.9\n>\n> pyrsistent               0.19.3\n>\n> python-dateutil          2.8.2\n>\n> python-json-logger       2.0.4\n>\n> pytz                     2022.4\n>\n> PyWavelets               1.4.1\n>\n> pywin32                  305\n>\n> pywinpty                 2.0.10\n>\n> pyzmq                    25.0.0\n>\n> qtconsole                5.4.0\n>\n> QtPy                     2.3.0\n>\n> regex                    2023.10.3\n>\n> requests                 2.25.1\n>\n> rfc3339-validator        0.1.4\n>\n> rfc3986-validator        0.1.1\n>\n> Send2Trash               1.8.0\n>\n> sentencepiece            0.1.99\n>\n> setuptools               68.2.2\n>\n> six                      1.16.0\n>\n> sklearn                  0.0.post1\n>\n> sniffio                  1.3.0\n>\n> soupsieve                2.3.2.post1\n>\n> stack-data               0.6.2\n>\n> sympy                    1.12\n>\n> terminado                0.17.1\n>\n> tifffile                 2023.2.28\n>\n> tinycss2                 1.2.1\n>\n> torch                    2.1.2\n>\n> torchaudio               2.1.2\n>\n> torchdata                0.7.1\n>\n> torchtext                0.6.0\n>\n> torchvision              0.16.2\n>\n> tornado                  6.2\n>\n> tqdm                     4.66.1\n>\n> traitlets                5.8.1\n>\n> typing_extensions        4.4.0\n>\n> tzdata                   2023.3\n>\n> urllib3                  1.26.14\n>\n> wcwidth                  0.2.6\n>\n> webencodings             0.5.1\n>\n> websocket-client         1.5.0\n>\n> Werkzeug                 3.0.1\n>\n> wheel                    0.41.2\n>\n> widgetsnbextension       4.0.5\n>\n> xlrd                     2.0.1\n>\n> zipp                     3.11.0\n\n### 5.3. 训练信息\n\n这段模型训练文件的相关信息总结如下：\n\n### 模型结构\n\n- **textCNN模型**： \n\n- - 输入：文本序列\n  - 嵌入层：词表大小为 `vocab_size`，嵌入维度为 `embed_dim`\n  - 三个卷积核（kernel_num=16）：分别大小为 3、4、5\n  - Dropout层：丢弃率为 0.5\n  - 全连接层：输出类别数量为 `class_num`（这里为2）\n\n### 数据处理\n\n- 通过 `word2vec` 模块加载词表映射，得到 `word2ind` 和 `ind2word`。\n- 数据集参数 `dataLoader_param`： \n\n- - `batch_size`: 128\n  - `shuffle`: True\n\n### 训练过程\n\n- 优化器：Adam，学习率为 0.01\n- 损失函数：负对数似然损失（NLLLoss）\n- 模型参数初始化： \n\n- - 如果已存在保存的权重文件 `textCNN.pkl`，则加载权重\n  - 否则，使用 `init_weight` 方法初始化权重\n\n- 日志记录：每个epoch记录每个batch的训练损失，保存在日志文件 `log_YYMMDDHH.txt` 中。\n- 训练时遍历数据集，进行前向传播、计算损失、反向传播更新参数。\n- 每50个batch输出一次当前epoch的训练损失。\n- 每个epoch结束后输出该epoch的平均训练损失。\n- 训练总共进行了100个epoch。\n\n### 模型保存\n\n- 训练完成后，保存模型权重到文件 `textCNN.pkl`。\n\n### 5.4. 训练结果\n\n![WXJ95.png](https://i.imgs.ovh/2023/12/20/WXJ95.png)\n\n最后，经过100轮训练，可将验证损失控制在0.01，效果良好。\n\n## 6. 模型测试\n\n经过类似的步骤，执行test.py文件即可得到测试结果，并将结果保存至日志文件log_test中\n\n![WXiuX.png](https://i.imgs.ovh/2023/12/20/WXiuX.png)\n\n可以看到，测试准确率也维持在97%以上，模型可用。\n\n## 7. 本地部署\n\n主要利用Flask进行本地网络api部署，操作简单易行，同时提供了html页面进行简单测试，也可使用接口测试工具如apifox、postman进行测试。\n\n### 7.1. 代码文件\n\n![WXjdU.png](https://i.imgs.ovh/2023/12/20/WXjdU.png)\n\n### 7.2. api解析\n\n![WXYsC.png](https://i.imgs.ovh/2023/12/20/WXYsC.png)\n\n### 7.3. 网页html测试\n\n![WXdUt.png](https://i.imgs.ovh/2023/12/20/WXdUt.png)\n\n### 7.4. 接口测试工具测试\n\n这里以apifox为例：\n\n![WXDPm.png](https://i.imgs.ovh/2023/12/20/WXDPm.png)\n\n## 8. 云部署\n\n### 8.1. 部署环境\n\n- 阿里云轻量应用服务器，系统为centos7\n- conda环境：如未安装，可参考此博客：https://blog.csdn.net/wyf2017/article/details/118676765\n- 使用前根据本文5.2安装依赖即可\n- 记得将本地文件上传至服务器\n\n### 8.2. 配置并使用Gunicorn 服务\n\n#### 8.2.1. 什么是Gunicorn 服务\n\n在生产环境中，Flask自带的开发服务器通常不适用于处理高负载和并发请求。Flask的开发服务器是单线程的，并不是为了处理大量并发请求而设计的。它更适合在开发环境中使用，用于调试和测试。\n\n以下是使用 Flask开发服务器的一些主要限制：\n\n1.  **单线程处理请求：** Flask的开发服务器是单线程的，意味着它一次只能处理一个请求。在高并发情况下，这可能导致性能瓶颈。 \n2.  **不适合生产环境：** Flask的开发服务器没有被设计为在生产环境中处理大规模负载的工具。它缺乏许多生产服务器所具有的优化和安全功能。 \n3.  **有安全风险：** Flask的开发服务器没有像生产级服务器那样经过严格的安全审查和配置。在生产环境中使用它可能会增加安全风险。 \n\n为了解决这些问题，通常建议在生产环境中使用专业的Web服务器，如Gunicorn、uWSGI等。这些服务器可以处理更多的并发请求，提供更好的性能和安全性，并具有适用于生产环境的配置选项。\n\nGunicorn就是在生产环境中使用专业的Web服务器。\n\n#### 8.2.2. 如何使用\n\n在使用 Gunicorn 启动 Flask 应用时，可以使用 Gunicorn 的 `--workers` 选项指定工作进程的数量，以实现并发处理请求。每个工作进程都是一个独立的进程，可以独立运行应用代码。\n\n以下是一些示例命令，演示如何在 Gunicorn 中启动 Flask 应用并设置多个工作进程：\n\n```bash\ngunicorn -w 4 -b 0.0.0.0:9102 predict_online:app\n```\n\n在这个例子中：\n\n- `-w 4` 指定了使用 4 个工作进程。\n- `-b 0.0.0.0:9102` 指定了绑定的地址和端口。\n- `predict_online:app` 指定了要运行的 Flask 应用。\n\n请注意，`predict_online` 应该是你文件中定义 Flask 应用的地方。\n\n此外，你可以考虑使用 Gunicorn 的其他配置选项，例如 `--preload`，这将在每个工作进程启动时加载应用代码，而不是在每个请求中加载。这样可以减少工作进程的启动时间，提高性能。\n\n```bash\ngunicorn -w 4 -b 0.0.0.0:9102 --preload predict_online:app\n```\n\n确保在生产环境中使用专业的 Web 服务器（如 Gunicorn）来运行 Flask 应用，以确保应用能够正确处理并发请求并保持稳定性。\n\n当使用 Gunicorn 的 `--preload` 选项时，应用代码会在每个工作进程启动时加载，而不是在每个请求中动态加载。这个过程称为应用的“预加载”。\n\n**动态加载（非预加载）**：\n\n在动态加载模式下，每当接收到一个请求时，Gunicorn 会动态地加载应用代码并初始化应用。这意味着在每个请求处理之前，都会执行一次应用的初始化过程。这种方式的好处是在运行时可以动态更新应用代码，但也可能导致每个请求都需要花费额外的时间来加载和初始化应用。\n\n**预加载**：\n\n在预加载模式下，应用代码会在工作进程启动时加载和初始化。这意味着在工作进程启动时，应用的所有代码都被加载到内存中，并且在处理请求时无需再次加载。这样一来，每个请求的处理过程更加高效，因为不需要在请求级别进行初始化操作。然而，这也意味着在更新应用代码时，你需要重新启动工作进程，以便使新的代码生效。\n\n假设你有一个 Flask 应用，其中包含一些全局变量或初始化操作。在动态加载模式下，这些初始化操作会在每个请求中执行。在预加载模式下，这些初始化操作会在工作进程启动时执行，而不会在每个请求中重复执行。\n\n在动态加载模式下，`some_global_variable` 的初始化操作将在每个请求中执行。在预加载模式下，初始化操作只会在工作进程启动时执行一次，而后续的请求将直接使用已初始化的变量，而不需要重新执行初始化。\n\n\n\n#### 8.2.3. worker和负载均衡\n\n在 Gunicorn 中，worker 是处理请求的工作单元，而 master 则是管理这些 worker 的主进程。在 Gunicorn 的工作模型中，master 进程负责监听端口、接收请求，并将请求分配给不同的 worker 进程进行处理。\n\nGunicorn 支持多种 worker 类型，包括 sync（同步）、eventlet、gevent、tornado 等。这些 worker 的主要区别在于它们处理请求的方式。下面是关于 Gunicorn worker 的一些关键概念：\n\n1.  **Master 进程**： \n\n- - 主进程，负责启动和管理所有 worker 进程。\n  - 监听端口，接收客户端的连接请求。\n  - 当有请求到达时，负责将请求分配给可用的 worker 进程。\n\n1.  **Worker 进程**： \n\n- - 工作进程，实际处理客户端请求的单元。\n  - 一个 Gunicorn 实例可以有多个 worker 进程，每个 worker 处理一个请求。\n  - Worker 之间是独立的，它们可以并发处理多个请求。\n\n1.  **Worker 类型**： \n\n- - Gunicorn 支持多种 worker 类型，包括 sync（同步）、eventlet、gevent、tornado 等。\n  - 同步 worker 在每个进程中处理一个请求，而异步 worker 可以处理多个请求。\n\n1.  **并发性**： \n\n- - Worker 的数量和并发连接数之间有关系。更多的 worker 可以处理更多的并发请求。\n  - 例如，使用 `-w` 参数可以指定启动的 worker 数量，如 `gunicorn -w 4 myapp:app` 表示启动 4 个 worker 进程。\n\n1.  **负载均衡**： \n\n- - Master 进程通过简单的轮询或其他算法将请求分配给不同的 worker 进程，实现简单的负载均衡。\n  - Gunicorn 还支持其他负载均衡算法，如预先分配请求到不同的 worker。\n\n总体而言，master 进程和多个 worker 进程之间的关系是一种主从关系。Master 进程负责管理和分配任务，而 worker 进程负责实际的请求处理。这种结构使得 Gunicorn 能够更好地利用多核处理器，并提供高性能的 Web 服务。\n\n#### 8.2.4. 执行部署\n\n由此，我们可以使用以下命令，实现最终的部署：\n\n```bash\nnohup gunicorn -w 3 -b 0.0.0.0:9102 --preload predict_online:app &\n```\n\n执行结果：\n\n![WXTeR.png](https://i.imgs.ovh/2023/12/20/WXTeR.png)\n\n后台运行日志文件：\n\n![WXqGp.png](https://i.imgs.ovh/2023/12/20/WXqGp.png)\n\n可见，已成功启动。\n\n### 8.3. 部署效果\n\n使用apifox测试：\n\n![WXNuu.png](https://i.imgs.ovh/2023/12/20/WXNuu.png)\n\n## 9. 源码地址和结构说明\n\n- Gitee开源地址：https://gitee.com/crzzx/comment_moderation\n- 项目代码结构和说明：\n\n```lua\nE:.\n│  .gitignore\n│  comment_test_demo.html # 前端测试代码\n│  example.log\n│  LICENSE\n│  model.py # 模型文件\n│  predict.py # 预测代码\n│  predict_online.py # 预测代码上线版\n│  README.en.md\n│  README.md # 说明文档\n│  test.py # 模型测试代码\n│  textCNN_data.py # 数据集生成代码\n│  train.py # 模型训练代码（cpu版本）\n│  train_gpu.py # 模型训练代码（gpu版本）\n│  __init__.py\n│\n├─data\n│  │  dev.txt # 验证数据集\n│  │  stop_word.txt # 停词表\n│  │  test.txt # 测试数据集\n│  │  train.txt # 验证数据集\n│  │\n│  ├─logs\n│  ├─result\n│  │      log_23121911.txt # 训练日志\n│  │      log_test_23121914.txt # 测试日志\n│  │      test_vec.txt # 测试集词向量\n│  │      textCNN.pkl # 训练好的模型文件\n│  │      train_vec.txt # 训练集词向量\n│  │      valid_vec.txt # 验证集词向量\n│  │      word_list.txt # 词表\n│  │\n│  └─suspect\n│          illegal.txt # 政治敏感词\n│          illegal_char_split.txt\n│          suspected_illegal.txt # 辱骂词\n│\n├─data_process\n│  │  generate_word_list.py # 词表生成代码\n│  │  word2vec.py # 词向量生成代码\n│  │  __init__.py\n│  │\n│  └─__pycache__\n│          word2vec.cpython-39.pyc\n│          __init__.cpython-39.pyc\n│\n└─__pycache__\n        model.cpython-39.pyc\n        textCNN_data.cpython-39.pyc\n        __init__.cpython-39.pyc\n```\n\n## 10. 总结\n\n本文介绍了基于TextCNN文本分类模型的实现和部署，主要解决了新闻文章评论区存在的谩骂言辞问题。以下是文章的主要内容和步骤：\n\n> ### 1. 问题描述：\n>\n> 文章提到新闻文章评论区经常充斥着辱骂言辞，损害了平台声誉和用户体验。为了解决这个问题，需要建立一个自动识别算法，通过模型拦截谩骂评论，提升评论区的品质。\n>\n> ### 2. 算法结构和思路：\n>\n> 文章详细描述了解决问题的算法结构和设计思路，包括：\n>\n> - 预处理阶段：文本清洗和分词处理。\n> - 辱骂违规词检测：建立违规词库，采用多层次匹配策略和动态过滤机制。\n> - 政治敏感词检测：建立敏感词库，进行关联性分析。\n> - TextCNN模型：使用卷积神经网络结构，包括嵌入层、卷积层、全连接层等。\n> - 输出和审核结果：综合判断辱骂违规词检测、政治敏感词检测和TextCNN模型的输出。\n>\n> ### 3. 数据来源：\n>\n> 文章引用了一个参考文章和一个数据来源链接，其中数据来源包括了违规词和政治敏感词。\n>\n> ### 4. 模型选择和训练：\n>\n> 文章选择了TextCNN模型，并提供了模型的结构图和关于嵌入层的详细解释。描述了数据处理、训练和验证的过程，以及模型的保存和测试效果。\n>\n> ### 5. 本地部署：\n>\n> 使用Flask进行本地网络API部署，提供了HTML页面进行简单测试，同时使用Gunicorn处理高并发的服务器。\n>\n> ### 6. 云部署：\n>\n> 介绍了在阿里云轻量应用服务器上的部署环境和配置，并通过Gunicorn进行服务启动。详细说明了Gunicorn的工作原理、worker和负载均衡的概念，以及如何使用Gunicorn进行生产环境部署。\n>\n> ### 7. 代码结构和文件说明：\n>\n> 提供了项目的Gitee开源地址、代码结构和各个文件的功能说明。",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 3,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1721896042632441858",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-20T05:17:16.000+00:00",
        "updateTime": "2023-12-22T10:42:10.000+00:00",
        "user": {
          "id": "1721896042632441858",
          "planetCode": "29240",
          "userName": "南侠（准）",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELkfM4IsxxWrB70flGuaDcq55mDxh8r4DuwOJLuluSmRCH9Pk1MFibry5icVgHtfwMmnYGqT49svVKV3X1wMer2OCC3ob5leZX5lF8HMbPo1Qww/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-11-05T14:14:23.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-11-07T14:23:02.000+00:00",
          "updateTime": "2023-11-09T14:34:06.000+00:00"
        },
        "tags": [
          "文章",
          "人工智能",
          "项目",
          "Python",
          "开源",
          "算法"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1737073018305273858",
        "title": "要是工作前就知道这个，该多好。",
        "description": null,
        "content": "大家好，我是鱼皮。\n\n前几天直播和大家交流时，有一位小伙伴问我：我现在是外包，如何提升自己？\n\n这让我想到了之前的提问：我的工作天天都是重复的 CRUD，如何提升自己？\n\n其实这两个问题可以统一为：如何在工作中提升自己？\n\n因为每个人的公司、工作情况、环境、职责都不同，所以我们暂且不考虑工作过程中大家得到的成长，我想给大家重点分享的，是我们如何在工作后自主提升？\n\n也就是说，无论工作如何，我们自己能做哪些事情，来帮助自己更快成长呢？\n\n虽然我的工作经验比不上十年的大佬，但算上实习和正式工作，也在公司总共待了快 5 年了，我觉得自己在工作后的成长是非常快的，因此有很多自己的工作提升方法，给大家分享分享。\n\n建议大家直接看视频：https://www.bilibili.com/video/BV1DC4y177sB/\n\n以下文字版，就提炼一些关键内容给大家。\n\n工作后怎么提升自己？\n做好以下 6 件事：\n\n1、每日阅读\n每天读 2 - 3 篇文章，可以是行业趋势、技术干货（自己的工作有关的方向）、经验分享、思维提升等。坚持一年，你就读了将近 1000 篇文章，相当于几十个教程，绝对大有裨益。\n\n文章从哪儿找？\n\n大厂的技术博客：适合想学硬核技术的同学，比如美团技术团队、阿里技术团队\n科技资讯类：量子位、差评、新智元、无敌信息差（我们自己的号）\n经验分享、编程趋势、技术干货：程序员鱼皮、小林 coding、java guide、程序喵、神光的编程笔记、小白 debug、古时的风筝、苏三、阿秀等（很多都是我们一起写文章的朋友）\n2、技术学习\n对程序员来说，一定要持续学习新技术。每天只需要抽不到 1 小时，看 2 - 3 集教程，那么坚持一个月，你就能看完一套课程。\n\n或者每天写 100 行代码，一周一个功能，那么坚持一个月，你就能做好一个项目。\n\n3、复盘总结\n之前也给大家分享过，这是我坚持多年的习惯。\n\n可以尝试做以下几件事：\n\n每天记录自己完成的工作，哪怕贴个需求链接啥的也可以\n每月记录自己这个月重点在做的事情，以及完成的工作、学习的情况等\n每半年或者每完成一个大事，做一个复盘总结。记录自己做这件事情的经历、过程、结果、好和不好的地方，防止后面踩同样的坑。\n4、整理自己的弹药库\n为什么有些人工作五年，感觉还和工作一年一样？\n\n可能就是没有做好 积累 ，把之前的经验忘完了！\n\n所以，积累真的很重要，大家可以从以下几个方面下手：\n\n整理属于自己的 Bug 库，记录你解决过的问题\n整理属于自己的经验库，记录你踩过的坑\n知识碎片积累：把你学过的所有知识点，以碎片的形式进行记录整理，后面要做项目时都可以复用\n软件库（工具库）：整理自己的常用软件、工具，保证自己工作的高效\n5、分享\n只要你做到了上面几件事，那么你一定是有非常多能分享的内容的。\n\n比如：\n\n分享自己的复盘总结和个人经历\n分享自己的弹药库\n分享自己学过的知识点\n帮助别人答疑解惑\n直接把自己之前记录的内容分享出来，就会对别人有帮助，也会收获别人的关注和认可，从而给自己获取正向激励再帮助自己更快地提升，然后再分享更多内容，这是一个非常好的良性循环。\n\n我也是通过这种方式，从自己背过的面试题、再到自己的个人经历、再到自己的项目，依次给大家分享出来，才慢慢收获了更多人的关注，成为了一个博主。谢谢大家！\n\n6、目标拆解\n工作后想持续学习，其实是非常难的，因为我们会本能地担心由于工作的影响，没有更多精力和时间干大事。\n\n这种时候，我们一定要学会将目标拆解。比如你想做一个大项目，可以把它依次拆解为做一个子系统、做一个小的功能、小的模块、学一个技术、看一套课程、看一节教程、看 10 分钟教程。\n\n只要把目标拆解地足够小，做好计划表，然后按照计划，每天坚持执行就好了。\n\n最后还有一点，就是我们要多思考，比如我无法坚持学习，本质的问题是什么？跟改 Bug 一样，先发现问题、再针对性地解决，这才是我们遇到任何困境时的破局战略。\n\n种一棵树最好的时间是十年前，其次是现在。先从上面的任何一件事开始做起，坚持 21 天养成习惯，你就会意识到自己的改变，大家加油，共勉！",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/I8qDpwjP-SCR-20231219-qxjm.jpeg",
        "language": null,
        "viewNum": 50,
        "thumbNum": 6,
        "favourNum": 0,
        "commentNum": 1,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-19T11:30:55.000+00:00",
        "updateTime": "2023-12-23T12:23:42.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 3005,
          "coin": 170,
          "followeeNum": 1297,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2024-05-24T03:35:38.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-12-22T23:17:31.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1737043054050697218",
        "title": "你知道MySQL的CHAR也会变长存储吗",
        "description": "MySQL的CHAR和VARCHAR有什么区别？可以把 CHAR 全部用 VARCHAR 替换吗？",
        "content": "\n\n\n## 前言\n\n一个太常见的面试题是：**MySQL的CHAR和VARCHAR有什么区别**？\n\n如果你的答案只是：定/变长，性能不同，再加个尾部空格处理不同\n\n那么，**这篇文章一定会带给你一些收获**。\n\n看似简单的面试题，也许也会牵扯到许多底层知识，没有什么是理所当然的。\n\n#### 正文开始\n\n最近在MySQL官网上看到这样一句话：\n\n\n>Internally, for nonvariable-length character sets, fixed-length character columns such as CHAR(10) are stored in a fixed-length format. \n\n\n 对于「非变长字符集」，CHAR(10) 以定长格式存储，强调了「非变长字符集」\n\n那么，第一个疑问是，**对于「变长字符集」，CHAR(10) 还是定长存储吗？**\n\n作为佐证，《MySQL实战宝典》中说到：鉴于目前默认字符集推荐设置为 UTF8MB4，所以在表结构设计时，可以把 CHAR 全部用 VARCHAR 替换，底层存储的本质实现一模一样。\n\n所以，第二个疑问是，**CHAR比起VARCHAR真的一无是处吗？**\n\n带着这两个疑问，我们就开始今天的探索了。\n\n> 以下基于MySQL 8.0版本\n\n## CHAR定长，\"定\"的到底是什么\n\n对于CHAR(N)，N 的范围是 0 ~ 255，**指的是字符的个数，而非字节**。这一点非常重要。\n\n> CHAR，VARCHAR，TEXT都是字节；而BINARY，VARBINARY，BLOB都是字符。\n\n而对于「变长字符集」，一个字符对应的字节数是不确定的，而底层存储自然不会关心字符个数，对于VARCHAR而言，行格式的头部元数据也只会存储VARCHAR的字节长度，而非字符长度。\n\n## 我用的是变长字符集吗\n\nMySQL使用`character set`或`charset`来表达字符集。\n\n你可以采用如下命令查看MySQL提供的字符集， 其中`Default collation`代表默认的排序比较规则，`Maxlen`是一个字符对应的最大字节数。\n\n```\nmysql> SHOW CHARSET LIKE 'utf8%';\n--     SHOW CHARACTER SET LIKE 'utf8%'; \n+---------+---------------+--------------------+--------+\n| Charset | Description   | Default collation  | Maxlen |\n+---------+---------------+--------------------+--------+\n| utf8    | UTF-8 Unicode | utf8_general_ci    |      3 |\n| utf8mb4 | UTF-8 Unicode | utf8mb4_0900_ai_ci |      4 |\n+---------+---------------+--------------------+--------+\n```\n\nMySQL默认的字符集是 `utf8mb4` ，排序规则为 `utf8mb4_0900_ai_ci`，除非你在创建数据库，表，字段时显式指定，否则都采用这个默认值，而`utf8mb4`就是一个变长字符集。\n\n你还可以通过`SHOW CREATE TABLE`命令查看具体某一列的字符集。\n\n``` sql\nSHOW CREATE TABLE [表名称];\n```\n\n为了能够存储某些emoji表情，许多字段都会采取 `utf8mb4`作为字符集，因此大部分情况，字符串字段都会采用变长字符集。\n\n## 当「定长字符」遇上「变长字节」\n\n那现在问题就来了，CHAR是定字符数，但字符集导致了字符对应的字节数是不定的。因此：\n\n在「变长字符集」下，CHAR并非定字节存储，而底层存储只认字节不认字符，这该怎么办呢？\n\n这就取决于「存储引擎」和「行格式」的具体实现了。\n\n> 下面都基于InnoDB存储引擎\n\n### Redundant行格式\n\n一种很好想到的简单的做法是：化变为不变。即我们还是希望CHAR是定字节存储，但又要符合用户最大字符数的预期，那我们就让CHAR(N)的字节数为「字符集的一个字符对应的最大字节数*N」。\n\n#### 没用上的字节如何填充\n\n答案是用空格填充，直至CHAR(N)的实际字节数达到「字符集的一个字符对应的最大字节数*N」。\n\n-   存储 CHAR 值时，会用空格将其填充到指定的长度。\n-   查询 CHAR 值时，除非启用 `PAD_CHAR_TO_FULL_LENGTH SQL` 模式，否则会**删除尾部空格**。\n\n> 这与VARCHAR不同，VARCHAR在存储和查询时，会保留尾部空格，除非超过列的最大长度。\n>\n> 下面用官网的例子来理解一下：\n>\n> ``` sql\n> -- SQL:\n> CREATE TABLE vc (v VARCHAR(4), c CHAR(4));\n> INSERT INTO vc VALUES ('ab  ', 'ab  ');\n> -- RESULT:\n> SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;\n> +---------------------+---------------------+\n> | CONCAT('(', v, ')') | CONCAT('(', c, ')') |\n> +---------------------+---------------------+\n> | (ab  )              | (ab)                |\n> +---------------------+---------------------+\n> ```\n\n### Compact家族行格式\n\n> Dynamic 和 Compressed都是Compact衍生而来，Dynamic是MySQL8.0 InnoDB的默认行格式。因此，此处介绍的特性对如今广泛使用的 Dynamic 同样适用。\n\n在InnoDB的Compact行格式家族中，对变长字符集的CHAR有特殊优化：\n\n-   如果CHAR(N)的实际字节数小于等于N，不会在尾部追加空格直到达到「字符集的一个字符对应的最大字节数*N」（以utf8mb4为例，就是4 * N），而是追加到N，就停止。\n-   如果CHAR(N)的实际字节数大于N，不会在尾部追加空格\n\n#### 为什么仍然至少为N\n\n即便在Compact紧凑行格式下，CHAR都至少占N个字节，既然都已经是变长了，为啥还至少要N个字节呢？官方给出的解释是这样的：\n\n\n>Reserving the minimum space N in many cases enables column updates to be done in place without causing index page fragmentation. \n\n\n即在大部分情况下，预留N个字节能够避免「索引页分裂」问题。但继续说这个就跑题了，感兴趣的可以去查一下\n\n## 测试：验证结论\n\n以上都是理论，为了证明我不是在胡说八道，接下来搞点实战：\n\n先来建个表，注意这里用了NOT NULL：\n\n``` sql\nCREATE TABLE `char_test` (\n  `name` char(5) NOT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci\n```\n\n插入三条数据：\n\n``` sql\n INSERT INTO char_test(name) values ('😊😊😊😊😊');\n INSERT INTO char_test(name) values ('😊😊😊😊😊');\n INSERT INTO char_test(name) values ('😊😊😊😊');\n```\n\n> 😊的十六进制表达为：F0 9F 98 8A\n\n接下来找到数据文件：\n\n``` sql\n-- 通过这个命令拿到数据文件所在的目录\nshow variables like '%datadir%';\n```\n\n搜索F0 9F 98 8A\n\n\n\n![image-20231125221143591.png](https://pic.code-nav.cn/post_picture/1631488212859977730/qfdfRsBB-image-20231125221143591.png)\n为了方便你观察，我把它第二条数据和第三条数据单独拎出来看以下：\n\n\n第二条数据：\n\n```\n14 0000 1800 2d00 0000 0013 9400 0000 0338 7782 0000 00a4 0110 \n// 5个 F0 9F 98 8A\nf09f 988a f09f 988a f09f 988a f09f 988a f09f 988a\n```\n\n第三条数据：\n\n```\n1000 0020 ff98 0000 0000 1395 0000 0003 387c 8100 0000 a701 10 \n// 4个 F0 9F 98 8A\nf0 9f98 8af0 9f98 8af0 9f98 8af0 9f98 8a\n```\n\n看不懂？让我们简单看一下Dynamic行格式的组成（如果了解可以跳过）\n\n#### Dynamic行格式的组成\n\n##### 1、变长字段的长度\n\n如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」；\n\n##### 2、NULL\n\n因为是非NULL，所以不存在\n\n##### 3、头信息\n\n固定5字节\n\n##### 4、隐式数据\n\n由于没有指定主键，MySQL隐式生成6个字节的row_id，以及6个字节的trx_id和7个字节的roll_pointer 。\n\n##### 5、实际数据\n\n最后就是列的实际值。\n\n整体上看就是下面这样（网上找来的图，侵删）\n\n\n\n![COMPACT.drawio.png](https://pic.code-nav.cn/post_picture/1631488212859977730/lnvlC12y-COMPACT.drawio.png)\n### 重新审视实验结果\n\n有了上面的基础，相信大家就能看懂了。\n\n我们观察到第一个位置的14和10，十六进制表达，转为十进制，即为20和16。\n\n隐式主键为 0000 0000 1394 和 0000 0000 1395，后跟13字节的trx_id 和 roll_ptr。实验结果符合理论基础。\n\n至此，我们可以确定：\n\n**CHAR也被InnoDB当作变长字段，使用了「行格式中的变长字段长度列表」来表达CHAR的字节长度，即length()函数的返回值。**\n\n因此，现在可以说：**对于变长字符集，Dynamic行格式的InnoDB，CHAR和VARCHAR的底层存储是一样的。**\n\n#### 那性能呢\n\n即便底层存储是一样的，也不代表性能一定相同。\n\n经过笔者的可能不太精确的测试，得到的结论是：VARCHAR与CHAR的速度是差不多的。\n\n当然在字节数不同的情况下，二者的性能会各有起伏，但总的来说，十分接近。\n\n感兴趣的读者可以自己尝试一下，需要注意Buffer Pool的存在，由于Buffer Pool的缓存预热功能，可能即便重启MySQL，仍然会有部分数据页存在在Buffer Pool中，并且MySQL8.0并不提供任何能够清空Buffer Pool的命令\n\n> 包括`innodb_buffer_pool_size`设为0，`SELECT SQL_NO_CACHE ...`，`FLUSH TABLES` 等方案都是不行的\n\n### 小结\n\n在MySQL8.0，使用InnoDB引擎，及Dynamic行格式，并且采取变长字符集时，在存储底层CHAR是变长的。\n\n有时，CHAR占用的实际空间可能不仅会大于VARCHAR，而且在性能上慢于VARCHAR。\n\n因此，在绝大多数情况下，VARCHAR可以替代CHAR。",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 9,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1631488212859977730",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-19T09:31:51.000+00:00",
        "updateTime": "2023-12-23T10:46:37.000+00:00",
        "user": {
          "id": "1631488212859977730",
          "planetCode": "17561",
          "userName": "山山水水",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/Rzm68moWz4LwOia4T13J8XclX0kLo33VIDTB3XypyYC7VztnJDNkLraJKY5PeiaIlXWV8ibm6qC28bJpkgtVfAqFg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-03-02T04:52:54.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-03-03T02:54:36.000+00:00",
          "updateTime": "2023-03-03T04:52:53.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1736915166638923778",
        "title": "【Java基础】反射基础&简单模拟SpringMVC",
        "description": "【Java基础】反射基础&简单模拟SpringMVC",
        "content": "\n# 一.概述\n\n反射是指对于**任何一个Class类**，在**运行的时候**都可以**直接得到这个类全部成分**，使得我们可以**动态操作**Java代码，同时反射也**破坏了Java的封装性**。\n\n例如：在运行时,可以直接得到这个类的构造器对象（`Constructor`）、成员变量对象（`Field`）、成员方法对象（`Method`），不管是否为私有，这种**运行时动态获取类信息以及动态调用类中成分的能力称为Java语言的反射机制**。\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/dqxnMqcy-image.png)\n\n**反射的关键和核心思想**：必须先获取编译后的Class类对象，然后就可以分析类对象中的全部成分并进行一些操作。\n\n```java\nHelloWorld.java -> javac -> HelloWorld.class\n// 获取类对象\nClass c = HelloWorld.class;\n// 获取其他类中的各个成分....\n```\n\n**反射的用途**：反射为绝大部分Java框架的底层实现原理。它常常被用于**开发各种具有通用性的框架或者工具**。\n\n# 二.获取类对象\n\n## (1) 引入\n\n反射的第一步就是先获取Class类对象，然后我们便可以基于获取的类对象解析类中的全部成分。我们有三种方式可以获取类对象：\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/IMmRhlGd-image.png)\n\n\n三种方式对比显然直接通过`类名.class`方式获取最简单，但我们依旧需要看使用场景选择不同的方式。例如：假如我们需要获取方法参数传递对象的类对象，只能使用`对象.getClass()`。\n\n我们先创建一个学生类，用于获取类对象。\n\n```java\n// 反射学习\npackage relate;\n\npublic class Student {\n}\n```\n\n## (2) 第一种方式\n\n我们可以通过Class类的一个静态方法`forName(\"全限名\")`获取类对象\n\n```java\npackage relate;\n\npublic class Test {\n    public static void main(String[] args) throws ClassNotFoundException {\n        // 获取类对象\n        Class c = Class.forName(\"relate.Student\");\n        // 打印类对象，也可以直接通过getSimpleName获取类名\n        System.out.println(c+\"====>\"+c.getSimpleName());\n    }\n}\n\n// 打印结果\n// class relate.Student====>Student\n```\n\n**全限名**：可以看作是**包名+类名**。\n\n## (3) 第二种方式\n\n我们也可以通过一种更为简单的方式获取：`类名.class`。\n\n```java\npackage relate;\n\npublic class Test {\n    public static void main(String[] args) throws ClassNotFoundException {\n        // 获取类对象\n        Class c = Student.class;\n        // 打印类对象，，也可以直接通过getSimpleName获取类名\n        System.out.println(c+\"====>\"+c.getSimpleName());\n    }\n}\n// 打印结果相同\n// class relate.Student====>Student\n```\n\n## (4) 第三种方式\n\n此外我们还可以通过Object类中的getClass方法获取类对象：`对象.getClass()`\n\n```java\npackage relate;\n\npublic class Test {\n    public static void main(String[] args) throws ClassNotFoundException {\n        // 获取类对象\n        Student student = new Student();\n        Class c = student.getClass();\n        // 打印类对象，，也可以直接通过getSimpleName获取类名\n        System.out.println(c+\"====>\"+c.getSimpleName());\n    }\n}\n// 打印结果也相同\n// class relate.Student====>Student\n```\n\n我们已经获取了类对象，接下来便可以逐步解析类对象中的各个成分了，尽管类中存在一些私有的成分，但我们仍然可以获取到，也就是说可以**破坏封装性**\n\n# 三.获取构造器对象\n\n## (1) 引入\n\n我们可以通过反射获取类对象的任意构造器，然后再创建对象，尽管有些类的构造器是私有的，但并不妨碍我们基于此创建对象。\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/TSsahVJA-image.png)\n\n\nClass类提供了一些方法供我们获取构造器对象：\n\n| 方法                                                         | 说明                                                        |\n| ------------------------------------------------------------ | ----------------------------------------------------------- |\n| Constructor<?>[]  getConstructors()                          | 返回**所有**构造器对象的数组（**只能拿public的**）          |\n| Constructor<?>[]  getDeclaredConstructors()                  | 返回**所有**构造器对象的数组，**存在(包括private)就能拿到** |\n| Constructor<T>  getConstructor(Class<?>...  parameterTypes)  | 返回**单个**构造器对象，**只能拿public的**                |\n| Constructor<T>  getDeclaredConstructor(Class<?>...  parameterTypes) | 返回**单个**构造器对象，**存在包括private**都能拿到       |\n\n## (2) 获取多个构造器\n\n### (2.1) 公有构造器\n\n通过`getConstructors`方法我们只能获取所有的公有构造器：\n\n```java\n//    public Student() {\n//    }\n\n//    public Student(String name, int age) {\n//        this.name = name;\n//        this.age = age;\n //   }\n\npublic class Test {\n    public static void main(String[] args) {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取公有public构造器对象\n        Constructor[] constructors = c.getConstructors();\n        // 3.打印结果\n        for (Constructor constructor : constructors) {\n            System.out.println(constructor);\n        }\n    }\n}\n\n// 可以看到我们声明的两个构造器\n// public relate.Student()\n// public relate.Student(java.lang.String,int)\n```\n\n假如我们将带参的构造器改为私有的：\n\n```java\nprivate Student(String name, int age) {\n    this.name = name;\n    this.age = age;\n}\n```\n\n再次运行发现我们只能获取到公有的无参构造器，而私有的带参构造器则无法获取到\n\n```java\n// 打印结果\n// public relate.Student()\n```\n\n### (2.2) 任意构造器\n\n我们只需要使用`getDeclaredConstructors`即可获取所有构造器，包括私有构造器，这也是我们常用的。用法与上述类似：\n\n```java\n//    public Student() {\n//    }\n\n//    private Student(String name, int age) {\n//        this.name = name;\n//        this.age = age;\n //   }\n\npublic class Test {\n    public static void main(String[] args) {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取所有存在的构造器对象\n        Constructor[] constructors = c.getDeclaredConstructors();\n        // 3.打印结果\n        for (Constructor constructor : constructors) {\n            System.out.println(constructor);\n        }\n    }\n}\n// 打印结果\n// public relate.Student()\n// private relate.Student(java.lang.String,int)\n```\n\n## (3) 获取单个构造器\n\n我们也可以根据构造器参数的类型与数量获取单个构造器。\n\n### (3.1) 公有构造器\n\n我们可以通过`getConstructor`获取单个构造器，与上述类似，只能获取公有构造器\n\n```java\n//    public Student() {\n//    }\n\n//   public Student(String name, int age) {\n//       this.name = name;\n//        this.age = age;\n//   }\n\npackage relate;\n\nimport java.lang.reflect.Constructor;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取单个公有构造器对象\n        Constructor constructor1 = c.getConstructor();  // 无参直接方法名获取\n        Constructor constructor2 = c.getConstructor(String.class, int.class); // 带参数需要指定每个参数类型\n        // 3.打印结果\n        System.out.println(\"无参构造器===》\" + constructor1);\n        System.out.println(\"带参构造器===》\" + constructor2);\n    }\n}\n// 打印结果\n// 无参构造器===》public relate.Student()\n// 带参构造器===》public relate.Student(java.lang.String,int)\n```\n\n### (3.2) 任意构造器\n\n我们还可以通过`getDeclaredConstructor`获取单个任意构造器\n\n```java\n//    public Student() {\n//    }\n\n//    public Student(String name, int age) {\n//        this.name = name;\n//        this.age = age;\n//   }\n\npackage relate;\n\nimport java.lang.reflect.Constructor;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取任意构造器对象\n        Constructor constructor1 = c.getDeclaredConstructor(); // 无参直接方法名获取\n        Constructor constructor2 = c.getDeclaredConstructor(String.class, int.class); // 带参数需要指定每个参数类型\n        // 3.打印结果\n        System.out.println(\"无参构造器===》\" + constructor1);\n        System.out.println(\"带参构造器===》\" + constructor2);\n    }\n}\n// 打印结果\n// 无参构造器===》public relate.Student()\n// 带参构造器===》private relate.Student(java.lang.String,int)\n```\n\n## (4) 创建对象\n\n我们可以通过如下方法利用构造器对象创建对象。\n\n| 方法                                      | 说明                                                        |\n| ----------------------------------------- | ----------------------------------------------------------- |\n| T newInstance(Object...  initargs)        | 根据指定的构造器创建对象（若构造器为private需要先取消检查） |\n| public  void setAccessible(boolean  flag) | 设置为true,表示取消访问检查，进行暴力反射 ，**无视private** |\n\n### (4.1) 基于公有构造器\n\n我们可以基于获取到的构造器对象来创建对象。\n\n```java\n//    public Student() {\n//    }\n\npackage relate;\n\nimport java.lang.reflect.Constructor;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取构造器对象\n        Constructor constructor = c.getDeclaredConstructor();\n\n        // 3.根据无参构造器创建对象，0个参数\n        Student student = (Student) constructor.newInstance();\n        System.out.println(student);\n    }\n}\n// 打印结果\n// Student{name='null', age=0}\n```\n\n### (4.2) 基于私有构造器\n\n尽管我们可以获取到私有构造器，但是通过其创建对象时会发现程序会抛出异常，这时因为我们还要通过`setAccessible`打开权限。这也暴露了我们使用单例模式并不能一定保证只有一个对象。\n\n```java\n//   private Student(String name, int age) {\n//       this.name = name;\n//        this.age = age;\n//   }\n\npackage relate;\n\nimport java.lang.reflect.Constructor;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取构造器对象\n        Constructor constructor = c.getDeclaredConstructor(String.class, int.class);\n\n        // 3.打开权限\n        constructor.setAccessible(true);\n\n        // 4.创建对象\n        Student student = (Student) constructor.newInstance(\"观止\", 19);\n        System.out.println(student);\n    }\n}\n// 打印结果\n// Student{name='观止', age=19}\n```\n\n# 四.获取成员变量对象\n\n## (1) 引入 \n\n我们同样可以通过反射获取类对象的任意成员变量并进行赋值或获取值。\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/7uiHEEfK-image.png)\n\n\nClass类也提供了一些方法供我们获取成员变量对象：\n\n| 方法                                  | 说明                                         |\n| ------------------------------------- | -------------------------------------------- |\n| Field[]  getFields()                  | 返回所有成员变量对象的数组（只能拿public的） |\n| Field[]  getDeclaredFields()          | 返回所有成员变量对象的数组，存在就能拿到     |\n| Field  getField(String  name)         | 返回单个成员变量对象（只能拿public的）       |\n| Field  getDeclaredField(String  name) | 返回单个成员变量对象，存在就能拿到           |\n\n需要注意的是：\n\n- `getFields`将返回所有的公共字段，**包括从父类中继承来的公共字段**。\n- `getDeclaredFields`则**只返回自身**包含的全部字段。\n\n## (2) 获取多个成员变量\n\n### (2.1) 公有成员变量\n\n可以通过`getFields`获取所有公有成员变量\n\n```java\n //   public String name;\n //   private int age;\n \nimport java.lang.reflect.Field;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取公有成员变量\n        Field[] fields = c.getFields();\n        // 3. 遍历打印结果\n        for (Field field : fields) {\n            System.out.println(field + \"===>\" + field.getName());\n        }\n    }\n}\n// 打印结果\n// public java.lang.String relate.Student.name ===> name ===> class java.lang.String\n```\n\n### (2.2) 任意成员变量\n\n可以通过`getDeclaredFields`获取所有任意成员变量\n\n```java\n //   public String name;\n //   private int age;\n\npackage relate;\n\nimport java.lang.reflect.Field;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取任意成员变量\n        Field[] fields = c.getDeclaredFields();\n        // 3. 遍历打印结果\n        for (Field field : fields) {\n            System.out.println(field + \" ===> \" + field.getName());\n        }\n    }\n}\n// 打印结果\n// public java.lang.String relate.Student.name ===> name ===> class java.lang.String\n// private int relate.Student.age ===> age ===> int\n```\n\n## (3) 获取单个成员变量\n\n### (3.1) 公有成员变量\n\n可以通过`getField`获取单个公有成员变量\n\n```java\npackage relate;\n\nimport java.lang.reflect.Field;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.根据名称获取公有成员变量\n        Field name = c.getField(\"name\");\n        // 3.打印结果\n        System.out.println(name + \" ===> \" + name.getName()+ \" ===> \" + name.getType());\n    }\n}\n// 打印结果\n// public java.lang.String relate.Student.name ===> name ===> class java.lang.String\n```\n\n### (3.2) 任意成员变量\n\n可以通过`getDeclaredField`获取单个任意成员变量\n\n```java\npackage relate;\n\nimport java.lang.reflect.Field;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.根据名称获取任意成员变量\n        Field age = c.getDeclaredField(\"age\");\n        // 3.打印结果\n       System.out.println(age + \" ===> \" + age.getName()+ \" ===> \" + age.getType());\n    }\n}\n// 打印结果\n// private int relate.Student.age ===> age ===> int\n```\n\n## (4) 赋值&获取值\n\n我们可以获取或修改对象的字段值，尽管有限字段是私有不对外暴露的，但依旧可以通过反射进行操作。\n\n| 方法                                  | 说明     |\n| ------------------------------------- | -------- |\n| void  set(Object obj, Object value)： | 赋值     |\n| Object  get(Object obj)               | 获取值。 |\n\n我们必须先创建对象，再进行操作，因为不基于对象，对象值是毫无意义的。\n\n```java\npackage relate;\n\nimport java.lang.reflect.Field;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        \n        // 2.获取成员变量\n        Field name = c.getDeclaredField(\"name\");\n        Field age = c.getDeclaredField(\"age\");\n        \n        // 3. 赋予访问私有字段权限\n        age.setAccessible(true);\n        \n        // 3.给字段赋值\n        Student student = new Student();\n        name.set(student, \"观止\");\n        age.set(student, 20);\n        \n        // 打印对象并获取字段值\n        System.out.println(student + \"===>\" + name.get(student) + \"===>\" + age.get(student));\n    }\n}\n\n// 打印结果\n// Student{name='观止', age=20}===>观止===>20\n```\n\n我们以前都是通过`对象.getXX`获取字段值和`对象.setXX()`设置值，而通过反射则是以`XX.get(对象)`获取字段值和`xx.set(对象，X)`设置值，刚好相反。\n\n# 五.获取方法对象\n\n## (1) 引入\n\n我们同样可以通过反射获取类对象的任意方法对象并且手动进行触发操作。\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/2bgB0Seg-image.png)\n\n\nClass类也提供了一些方法供我们获取方法对象：\n\n| 方法                                                         | 说明                                         |\n| ------------------------------------------------------------ | -------------------------------------------- |\n| Method[]  getMethods()                                       | 返回所有成员方法对象的数组（只能拿public的） |\n| Method[]  getDeclaredMethods()                               | 返回所有成员方法对象的数组，存在就能拿到     |\n| Method  getMethod(String  name, Class<?>... parameterTypes)  | 返回单个成员方法对象（只能拿public的）       |\n| Method  getDeclaredMethod(String  name, Class<?>... parameterTypes) | 返回单个成员方法对象，存在就能拿到           |\n\n需要注意的是：\n\n- `getMethods`将返回所有的公共方法，**包括从父类中继承来的公共方法**。\n- `getDeclaredMethods`则**只返回自身**包含的全部方法。\n\n我们为学生类添加三个方法用于测试：\n\n```java\n    public void run() {\n        System.out.println(\"invoke public run...\");\n    }\n\n    public void sing(String name) {\n        System.out.println(\"sing \" + name);\n    }\n\n    private void dance() {\n        System.out.println(\"invoke private dance...\");\n    }\n\n    private void eat(String name) {\n        System.out.println(\"eat \" + name);\n    }\n```\n\n## (2) 获取多个方法\n\n### (2.1) 公有方法\n\n我们可以通过`getMethods`获取类中所有的方法**包括其父类**中的方法。\n\n```java\npackage relate;\n\nimport java.lang.reflect.Method;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取多个成员方法\n        Method[] methods = c.getMethods();\n        // 3.遍历\n        for (Method method : methods) {\n\t\tSystem.out.println(\"方法名称：\"+method.getName()+\",返回值类型：\"+method.getReturnType()+\",参数个数：\"+method.getParameterCount());\n        }\n    }\n}\n// 除了Student类中的方法，其继承自Object的方法也会打印\n// 方法名称：run，返回值类型：void，参数个数：0\n// 方法名称：toString，返回值类型：class java.lang.String，参数个数：0\n// 方法名称：wait，返回值类型：void，参数个数：2\n// 方法名称：wait，返回值类型：void，参数个数：1\n// 方法名称：wait，返回值类型：void，参数个数：0\n// 继承自Object.....\n```\n\n### (2.2) 任意方法\n\n我们可以看到上述虽然获取到了很多方法，但并没有获取到私有的两个方法，我们可以通过`getDeclaredMethods`获取任意方法。\n\n```java\npackage relate;\n\nimport java.lang.reflect.Method;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取多个成员方法\n        Method[] methods = c.getDeclaredMethods();\n        // 3.遍历\n        for (Method method : methods) {\n            System.out.println(\"方法名称：\"+method.getName()+\"，返回值类型：\"+method.getReturnType()+\"，参数个数：\"+method.getParameterCount());\n        }\n    }\n}\n// Student类中声明的任意方法\n// 方法名称：run，返回值类型：void，参数个数：0\n// 方法名称：toString，返回值类型：class java.lang.String，参数个数：0\n// 方法名称：dance，返回值类型：void，参数个数：0\n// 方法名称：eat，返回值类型：void，参数个数：1\n```\n\n## (3) 获取单个方法\n\n### (3.1) 公有方法\n\n我们可以通过`getMethod`获取单个公有方法对象。\n\n```java\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取公有成员方法\n        Method run = c.getMethod(\"run\"); // 无参直接方法名获取\n        Method sing = c.getMethod(\"sing\", String.class); // 带参数需要指定每个参数类型\n\n        // 3.打印结果\n        System.out.println(\"方法名称：\"+run.getName()+\"，返回值类型：\"+run.getReturnType()+\"，参数个数：\"+run.getParameterCount());\n        System.out.println(\"方法名称：\"+sing.getName()+\"，返回值类型：\"+sing.getReturnType()+\"，参数个数：\"+sing.getParameterCount());\n    }\n}\n\n// 打印结果\n// 方法名称：run，返回值类型：void，参数个数：0\n// 方法名称：sing，返回值类型：void，参数个数：1\n```\n\n### (3.2) 私有方法\n\n我们可以通过`getMethod`获取任意方法对象。\n\n```java\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取私有成员方法\n        Method dance = c.getDeclaredMethod(\"dance\"); // 无参直接方法名获取\n        Method eat = c.getDeclaredMethod(\"eat\", String.class); // 带参数需要指定每个参数类型\n\n        // 3.打印结果\n        System.out.println(\"方法名称：\"+dance.getName()+\"，返回值类型：\"+dance.getReturnType()+\"，参数个数：\"+dance.getParameterCount());\n        System.out.println(\"方法名称：\"+eat.getName()+\"，返回值类型：\"+eat.getReturnType()+\"，参数个数：\"+eat.getParameterCount());\n    }\n}\n// 打印结果\n// 方法名称：dance，返回值类型：void，参数个数：0\n// 方法名称：eat，返回值类型：void，参数个数：1\n```\n\n## (4) 触发方法\n\n我们可以触发获取到的方法，不管它是否为私有方法。\n\n| 方法                                      | 说明                                                         |\n| ----------------------------------------- | ------------------------------------------------------------ |\n| Object invoke(Object obj, Object... args) | **参数一**：通过对象调用该方法  **参数二**：调用方法的传递的参数（如果没有可以不写）  **返回值**：方法的返回值（如果没有可以不写） |\n\n```java\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 1.获取类对象\n        Class c = Student.class;\n        // 2.获取私有成员方法\n        Method run = c.getDeclaredMethod(\"run\");\n        Method eat = c.getDeclaredMethod(\"eat\", String.class);\n\n        // 2.1 获取执行私有方法权限\n        eat.setAccessible(true);\n\n        // 3.创建对象用于触发方法\n        Student student = new Student();\n        // 4. 触发方法\n        Object runRes = run.invoke(student); // 没返回值runRes为null\n        Object eatRes = eat.invoke(student, \"水果\");  // 没返回值eatRes为null\n\n        // 3.打印结果\n        System.out.println(\"runRes===>\" + runRes + \"，eatRes===>\" + eatRes);\n    }\n}\n// 打印结果\n// invoke public run...\n// eat 水果\n// runRes===>null，eatRes===>null\n```\n\n# 六.作用\n\n## (1) 泛型擦除\n\n由于反射是作用在**运行时**的技术，而泛型**只在编译阶段可以约束**只能操作某种数据类型，使用**反射泛型将不能产生对我们产生约束**，此时就相当于泛型被擦除了。\n\n\n\n**例如**：我们编写如下代码时，往集合添加Integer类型数据不会产生报错，而添加其他类型数据将无法通过编译。\n\n```java\nArrayList<Integer> list = new ArrayList<>();\nlist.add(100);   // 合法\n// list.add(“观止\"); // 产生编译错误\nlist.add(99);  // 合法\n```\n\n而使用反射操作，此时集合的泛型将不能产生约束，**可以为集合存入其他任意类型的元素的**。泛型只是在编译阶段可以约束集合只能操作某种数据类型，在编译成Class文件进入运行阶段的时候，其真实类型都是ArrayList了。\n\n```java\npublic class Test {\n    public static void main(String[] args) throws Exception {\n\n        // 1.创建对象\n        ArrayList<Integer> list = new ArrayList<>();\n        // 尝试添加\n        list.add(666);\n//        list.add(\"观止\"); // 报错\n        // 2.获取类对象\n        Class listClass = list.getClass();\n        // 3.获取add方法\n        Method add = listClass.getDeclaredMethod(\"add\", Object.class);\n        // 4.添加其他类型元素\n        add.invoke(list,\"观止\");\n        add.invoke(list,999);\n        // 5.打印查看数据是否添加\n        System.out.println(list);\n    }\n}\n// 打印结果\n// [666, 观止, 999]\n```\n\n可以看到外面不单单存在Integer类型数据，还存在它所不允许的String类型数据，跳过了泛型对我们的约束作用。\n\n## (2) 通用框架的底层原理\n\n几乎所有的框架实现都用到了反射技术，使用反射可以帮助我们很好的处理**多变**的情况。\n\n**例如**：给你任意一个对象，在不清楚对象字段的情况下，可以把对象的字段名称和对应值存储到文件中去。\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/ujfI0xV1-image.png)\n\n\n不使用反射显然我们无法对可变的情况进行固定的操作，更别说获取一些不对外暴露的私有字段。使用反射却能很好的帮助我们解决这种情况。\n\n```java\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        Student s = new Student(\"彭于晏\", 40, '男', 177.5, \"男星\");\n        printAllFiled(s);\n        Teacher t = new Teacher(\"观止\", 6000);\n        printAllFiled(t);\n\n    }\n\n    public static void printAllFiled(Object obj) throws IllegalAccessException {\n        // 1.获取类对象\n        Class objClass = obj.getClass();\n        // 2. 获取类名打印横幅\n        System.out.println(\"========\" + objClass.getSimpleName() + \"========\");\n        // 3.获取所有字段\n        Field[] fields = objClass.getDeclaredFields();\n        // 4.打印所有字段以及字段值\n        for (Field field : fields) {\n            // 5. 允许访问操作私有字段\n            field.setAccessible(true);\n            System.out.println(field.getName() + \" = \" + field.get(obj));\n        }\n    }\n}\n\n```\n\n可以看到即使我们的类结构存在差异它也能正常的获取并打印数值。\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/BjmODyCy-image.png)\n## (3) 简单模拟SpringMVC\n我们知道使用SpringMVC大幅度的简化了我们使用Servlet开发需要重复写大量类和重复代码的烦恼。我们使用反射加上上文所学的[自定义注解](https://blog.csdn.net/m0_66570338/article/details/129942054)可以简单模拟一下SpringMVC中`@RequestMapping`的功能。\n\n- 导入servlet所需要的坐标并进行一些配置\n\n```xml\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>javax.servlet-api</artifactId>\n            <version>4.0.1</version>\n            <scope>provided</scope>\n        </dependency>\n        <!--    确保能获取方法参数列表真实名称-->\n    <build>\n        <plugins>\n            <plugin>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.8.1</version>\n                <configuration>\n                    <source>1.8</source>\n                    <target>1.8</target>\n                    <encoding>utf8</encoding>\n                    <compilerArgs>\n                        <arg>-parameters</arg>\n                    </compilerArgs>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n```\n- 自定义`@RequestMapping`注解\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RequestMapping {\n    String value();\n}\n```\n- 创建一个Servlet简单模拟在SpringMVC中配置请求路径的写法\n\n```java\n// 接收以AppServlet开头的任意路径\n@WebServlet(\"/AppServlet/*\")\npublic class AppServlet extends HttpServlet {\n\n    // mvc请求路径 -> 方法对象\n    Map<String, Method> hashmap = new HashMap<>();\n\n    // 获取并加载所有存在注解的映射路径以及方法对象\n    @Override\n    public void init() {\n        // 1. 获取类对象\n        Class<AppServlet> appServletClass = AppServlet.class;\n        // 2. 获取所有方法\n        Method[] methods = appServletClass.getDeclaredMethods();\n        // 3. 保存所有路径\n        for (Method method : methods) {\n            // 判断是否存在注解\n            boolean present = method.isAnnotationPresent(RequestMapping.class);\n            if (present) {\n                // 将路径+方法对象存入map\n                RequestMapping annotation = method.getAnnotation(RequestMapping.class);\n                String path = annotation.value();\n                hashmap.put(path, method);\n            }\n        }\n    }\n\n \t// 作为中转站，根据请求路径转发到对应注解匹配的路径\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setCharacterEncoding(\"utf-8\");    //设置 HttpServletResponse使用utf-8编码\n        response.setHeader(\"Content-Type\", \"text/html;charset=utf-8\");    //通知浏览器使用utf-8解码\n        // 0.获取请求路径\n        String requestURI = request.getRequestURI();\n        String targetPath = requestURI.substring(\"/MyMVC_war/AppServlet\".length());\n        // 获取请求参数集合\n        ArrayList list = new ArrayList();\n        Map<String, String[]> parameterMap = request.getParameterMap();\n        // 3. 创建对象用于触发方法\n        AppServlet appServlet = new AppServlet();\n        // 判断请求路径是否存在\n        if (hashmap.containsKey(targetPath)) {\n            // 存在调用方法\n            try {\n                Method method = hashmap.get(targetPath);\n                Object res = \"\";\n                // 判断方法是否带参数\n                if (method.getParameterCount() == 0) {\n                    // 无参\n                    res = method.invoke(appServlet);\n                } else {\n                    // 带参\n                    for (Parameter parameter : method.getParameters()) {\n                        // 类型转换适配\n                        String value = parameterMap.get(parameter.getName())[0];\n                        if (value == null) {\n                            throw new RuntimeException(\"参数名称不匹配\");\n                        }\n                        list.add(convert(parameter.getType(), value));\n                    }\n                    // 参数传递\n                    res = method.invoke(appServlet, list.toArray());\n                }\n                response.getWriter().write(res.toString());\n            } catch (Exception e) {\n                throw new RuntimeException(\"server error 500!\", e);\n            }\n        } else {\n            response.getWriter().write(\"路径不存在\");\n        }\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        doGet(request, response);\n    }\n\n    // 将获取到的参数转为指定类型\n    public static Object convert(Class<?> type, String str) {\n        // 整型\n        if (type.isAssignableFrom(int.class) || type.isAssignableFrom(Integer.class)) {\n            return Integer.valueOf(str);\n        } else if (type.isAssignableFrom(double.class) || type.isAssignableFrom(Double.class)) {\n            // 浮点型\n            return Double.valueOf(str);\n        } else {\n            // 字符串\n            return str;\n        }\n    }\n\n\t// 模拟SpringMVC写法 \n    @RequestMapping(\"/add\")\n    private Object add(String name, int age) {\n        return \"add invoke ==> \" + name + \" ==> \" + age;\n    }\n\n    @RequestMapping(\"/delete\")\n    private Object delete(int id) {\n        return \"delete invoke:\" + id;\n    }\n\n    @RequestMapping(\"/update\")\n    private Object update() {\n        return \"update invoke\";\n    }\n\n    @RequestMapping(\"/select\")\n    private Object select() {\n        return \"select invoke\";\n    }\n\n}\n```\n- 通过postman进行测试\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/PkNy9muL-image.png)\n可以看到我们成功通过反射将请求路径映射到注解所对应的方法中\n\n\n\n\n\n\n\n\n\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619305100524748802/PDX2irG3-R-C.png",
        "language": null,
        "viewNum": 15,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619305100524748802",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-19T01:03:40.000+00:00",
        "updateTime": "2023-12-23T03:23:00.000+00:00",
        "user": {
          "id": "1619305100524748802",
          "planetCode": "6872",
          "userName": "观止.",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/OYu6LaaicHd8CDShMPqharTUTck82BzOggVOzdsF3AqPyVMRjAjEicQpvpQTQAeUFOvnsPuHLBTYNDWMgsg0r5LQ/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": -4,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 10,
          "coin": 100,
          "followeeNum": 9,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-01-28T13:18:24.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-28T12:03:15.000+00:00",
          "updateTime": "2023-12-20T09:18:47.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1736913669855404033",
        "title": "【Java基础】注解详述&简单模拟Junit框架",
        "description": "【Java基础】注解详述&简单模拟Junit框架",
        "content": "\n# 一.概述\n\nJava注解（Annotation）又称Java标注。我们可以使用注解来**标注**类，构造器，方法，成员变量，参数等。\n\n**问题来了，我们标注起来有什么作用呢？**\n\n程序在**编译**或者**运行**时可以检测到这些标记，我们或者框架底层可以对有标注的类，方法等**进行一些特殊的处理**，例如：\n\n- 标记了注解`@Test`的方法就可以被当作测试方法执行，而没有标记的就不能当成测试方法执行。\n- 我们在使用框架进行开发的过程中常常会用到注解来简化开发过程，例如`@Resource`,`@Component`等。\n- 将`@Override`放在方法前，在编译时会进行格式检查，如果你这个方法并不是覆盖了超类方法则会报错。\n\n注解就如同公路边的一个个路标，在你碰到的时提醒你注意一些事或者教你该做一些事了，就好比你看到一个急转弯路标，你就知道，该减速行驶了~\n\n# 二.自定义注解\n\n除了使用Java给我们提供的那些注解，我们还可以自己定义一个注解来使用。\n\n**语法格式**：\n\n```java\npublic @interface 注解名称 {\n    public 属性类型 属性名称() default 默认值;\n}\n```\n\n注意事项：\n\n- 注解类里可以声明**零个至多个**属性\n\n- 声明与接口类`interface`有点相似，不过前面多了`@`符号！！！\n- 属性类型为`public`时，`public`可以省略不写\n- 属性名称后面必须跟上`()`\n- `default 默认值`可以不写,不写时使用注解必须提供该属性值，有默认值则可以不提供。\n- 如果注解类中**没有属性或者属性全有默认值**，在使用时可以直接写成`@注解名称`\n- 以上只是简单形式，我们下面还会使用元注解进行完善。\n\n使用示例：\n\n```java\n// 例一\npublic @interface Book {\n    \n    public String bookName() default \"\";\n    \n    double price();\n}\n\n// 例二\npublic @interface Money {\n}\n\n// 可以用在类，方法，字段等地方\n@Book(bookName = \"《活着》\", price = 29.9)\npublic class MyClient {\n\n    // 可以都写上属性值\n    @Book(bookName = \"《活着》\", price = 29.9)\n    private String name;\n\n    // bookName 有默认值也可以不写\n    // price 无默认值必须赋值\n    @Book(price = 29.9)\n    public void save() {\n        System.out.println(\"test\");\n    }\n    \n    // 可以不写()\n    @Money\n    public void save() {\n        System.out.println(\"test\");\n    }\n}\n```\n\n**特殊属性：**\n\n- 如果注解中**只有一个**名为`value`的属性，使用注解的时候可以省略value的名称。\n- 如果**有多个属性且多个属性都有默认值**，也可以省略value的名称\n\n```java\n// 两种形式都可以省略\npublic @interface Book {\n    String value();\n}\n\npublic @interface Book {\n\tpublic String bookName() default \"\";\n    String value();\n}\n\n\npublic class MyClient {\n\n    // 使用时可以选择直接写上值\n    // @Book(value = \"test\")\n    @Book(\"test\")\n    public void save() {\n        System.out.println(\"test\");\n    }\n}\n```\n\n# 三.元注解\n\n## (1) 介绍\n\n用来注解注解的注解。意思就是我们可以在注解类上加上一些Java给我们提供的**特定注解**，用于对其的使用与状态进一步的标注。\n\n**常见的元注解有两个**：\n\n- `@Target`:**用于约束自定义注解只能在哪些地方使用**。例如我们上述自定义注解便没有进行约束以至于可在任意允许的地方使用。\n- `@Retention`:**申明注解的声明周期**，例如标注它只存在于编译阶段或者运行阶段或者一直存在。\n\n**常用值**：\n\n- `@Target`中可使用的值定义在ElementType枚举类中，常用值如下\n  - `TYPE`：类，接口\n  - `FIELD`：成员变量\n  - `METHOD`：成员方法PARAMETER,方法参数CONSTRUCTOR,构造器\n  - `LOCAL_VARIABLE`：局部变量\n\n- `@Retention`中可使用的值定义在RetentionPolicy枚举类中，常用值如下\n  - `SOURCE`:注解只作用在源码阶段，生成的字节码文件中不存在\n  - `CLASS`:注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值.\n  - `RUNTIME`:注解作用在源码阶段，字节码文件阶段，**运行阶段（开发常用)**\n\n## (2) 使用\n\n我们再使用元注解对上述自定义注解进行完善：\n\n```java\n// 标注该自定义注解存活于运行阶段\n@Retention(RetentionPolicy.RUNTIME)\n// 标注该自定义注解只能使用在方法上\n@Target(ElementType.METHOD)\npublic @interface Book {\n    \n    public String bookName() default \"\";\n    \n    double price();\n}\n\n// 测试类\n// @Book(bookName = \"666\",price = 666) 报错\npublic class MyClient {\n    \n\t// @Book(bookName = \"666\",price = 666) 报错\n    private String name;\n\n    @Book(bookName = \"666\",price = 666)\n    public void save() {\n        System.out.println(\"test\");\n    }\n}\n```\n\n再次进行测试我们发现该注解只能在方法上使用，在其他地方使用便会产生错误。\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/pL64qmnP-image.png)\n\n当然我们也可以给注解声明多个作用范围：\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD,ElementType.FIELD}) // 如此便可同时用于字段和方法上\npublic @interface Book {\n    \n    public String bookName() default \"\";\n    \n    double price();\n}\n\n// 测试类\n// @Book(bookName = \"666\",price = 666) 报错\npublic class MyClient {\n    \n\t@Book(bookName = \"666\",price = 666) \n    private String name;\n\n    @Book(bookName = \"666\",price = 666)\n    public void save() {\n        System.out.println(\"test\");\n    }\n}\n```\n\n# 四.注解的解析\n\n## (1) 介绍\n\n我们可以通过反射判断方法或者类等是否存在注解，存在注解我们可以解析出内容。\n\n**解析常用方法**：\n\n| 方法                                                         | 说明                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| Annotation[]  getDeclaredAnnotations()                       | 获得当前对象上使用的所有注解，返回注解数组。                 |\n| T getDeclaredAnnotation(Class<T>  annotationClass)           | 根据注解类型获得对应注解对象                                 |\n| boolean isAnnotationPresent(Class<Annotation>  annotationClass) | 判断当前对象是否使用了指定的注解，如果使用了则返回true，否则false |\n\n**解析注解的技巧**：\n\n- 注解在哪个成分上，我们就先拿哪个成分对象。\n\n-  比如注解作用成员方法，则要获得该成员方法对应的Method对象，再来拿上面的注解\n\n- 比如注解作用在类上，则要该类的Class对象，再来拿上面的注解\n\n- 比如注解作用在成员变量上，则要获得该成员变量对应的Field对象，再来拿上面的注解\n\n## (2) 使用\n\n同样是上述案例，我们来尝试解析获取一些注解内的内容。\n\n```java\n// 自定义注解\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD,ElementType.TYPE})\npublic @interface Book {\n    \n    public String bookName() default \"\";\n    \n    double price();\n}\n\n// 测试方法\n@Book(bookName = \"类注解\",price = 999)\npublic class MyClient {\n\n    @Book(bookName = \"方法注解\",price = 666)\n    public void save() {\n        System.out.println(\"test\");\n    }\n}\n```\n\n我们尝试利用**反射**来解析一下\n\n```java\npublic class Test{\n    public static void main(String[] args) throws NoSuchMethodException {\n\n        // 1. 先得到类对象\n        Class<MyClient> c = MyClient.class;\n        // 2. 判断这个类上是否存在这个注解\n        if (c.isAnnotationPresent(Book.class)){\n            // 3. 直接获取该注解对象\n            Book book = c.getDeclaredAnnotation(Book.class);\n            // 4. 获取属性值\n            System.out.println(\"=====类注解======\");\n            System.out.println(book.bookName());\n            System.out.println(book.price());\n        }\n\n        // 1. 先得到方法对象\n        Method method = c.getDeclaredMethod(\"save\");\n        // 2. 判断这个方法上是否存在这个注解\n        if (method.isAnnotationPresent(Book.class)){\n            // 3. 直接获取该注解对象\n            Book book = method.getDeclaredAnnotation(Book.class);\n            // 4. 获取属性值\n            System.out.println(\"=====方法注解======\");\n            System.out.println(book.bookName());\n            System.out.println(book.price());\n        }\n    }\n}\n```\n\n运行可以看到我们成功获取到了属性值\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/q9fb9QUh-image.png)\n\n# 五.模拟Junit框架\n\n注解与反射在我们的框架的底层实现中有着广泛的应用。接下来我们便来模拟一下Junit框架。\n\n- 我们的目的是：只要是加了自定义注解MyTest的方法，就可以在启动时被触发执行\n\n1. 定义一个自定义注解MyTest，要求只能注解方法并且一直都存在\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD})\npublic @interface MyTest {\n}\n```\n\n2. 定义若干个方法，只要有@MyTest注解的方法就能在启动时被触发执行，没有这个注解的方法不能执行\n\n```java\npublic class MyClient {\n\n    @MyTest\n    public void test1() {\n        System.out.println(\"test1......\");\n    }\n\n    @MyTest\n    public void test2() {\n        System.out.println(\"test2......\");\n    }\n\n    public void test3() {\n        System.out.println(\"test3......\");\n    }\n\n    @MyTest\n    public void test4() {\n        System.out.println(\"test4......\");\n    }\n}\n```\n\n3. 由于Junit框架是与IDEA进行了整合所有左边才有可直接run的绿三角，我们需要自己通过反射触发。\n\n```java\n// 在MyClient里添加一个main方法,通过反射模拟启动菜单\n public static void main(String[] args) throws InvocationTargetException, IllegalAccessException {\n        // 用于触发方法\n        MyClient myClient = new MyClient();\n\n        // 1. 先得到类对象和得到方法对象\n        Class<MyClient> c = MyClient.class;\n        Method[] methods = c.getDeclaredMethods();\n\n        // 2. 遍历判断方法上是否存在这个注解\n        for (Method method : methods) {\n            if (method.isAnnotationPresent(MyTest.class)){\n                // 3. 触发方法\n                method.invoke(myClient);\n            }\n        }\n    }\n```\n\n4. 启动可以看到只有我们添加了注解的1，2，4执行了，而没添加的则未执行\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/Np4a9zQW-image.png)\n如此我们便简单实现了Junit框架\n\n\n\n\n\n\n\n\n\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619305100524748802/SQr6zIPi-R-C.png",
        "language": null,
        "viewNum": 3,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619305100524748802",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-19T00:57:43.000+00:00",
        "updateTime": "2023-12-23T12:16:14.000+00:00",
        "user": {
          "id": "1619305100524748802",
          "planetCode": "6872",
          "userName": "观止.",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/OYu6LaaicHd8CDShMPqharTUTck82BzOggVOzdsF3AqPyVMRjAjEicQpvpQTQAeUFOvnsPuHLBTYNDWMgsg0r5LQ/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": -4,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 10,
          "coin": 100,
          "followeeNum": 9,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-01-28T13:18:24.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-28T12:03:15.000+00:00",
          "updateTime": "2023-12-20T09:18:47.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1736912760828092417",
        "title": "【Java基础】消灭魔法值-常量&枚举详述",
        "description": "【Java基础】消灭魔法值-常量&枚举详述",
        "content": "\n# 一.引入\n\n在开发中我们经常会遇到用一个值（诸如数字或字符串）表示一种状态的情况，例如：\n\n- 用 1 表示男，用 0 表示女\n- 用 0 表示状态正常，用 1 表示异常，用 2 表示封禁\n- 用 admin 表示管理员，用 common 表示普通用户\n- .....\n\n如果直接在代码中书写这些数值将大大破坏代码的可维护性，即使本人亲自编写的代码，在一段时间没接触之后，需要重新上手都得重新翻阅以前写的批注，如果没有写又不记得.....更何况有些时候代码都不是自己所编写的.... \n\n\n\n阿里巴巴Java开发规范手册中有提到：**不允许任何魔法值（即未经定义的常量）直接出现在代码中**。为了提高我们代码的可维护性，这也是许多人都遵从的一点。\n\n**什么是魔法值呢？**\n\n它通常是指在代码编写时**莫名出现的数字或字符串，我们无法直接判断数值代表的含义**，必须通过联系代码上下文分析才可以明白，严重降低了代码的可读性。结合我们上述所举的例子：\n\n```java\n// 不推荐\ngender.setGender(1); // 设置性别为男\n// 这里所使用的 1 就是一个魔法值\n```\n\n除此之外，如果在代码中使用了大量的魔法值，假设我们需要对其值进行修改那么工作量也是极其巨大的而且极易遗漏。\n\n为了解决这个问题，我们可以采用如下两种方式来做信息标志和分类：\n\n- 常量\n- 枚举\n\n# 二.常量\n\n我们可以先声明一个变量并且赋值，然后再使用，但是这样做用户可以随意的修改变量值，导致安全性大大降低。由此我们可以选择使用常量。\n\n## (1) 语法\n\n- **定义**：使用了`public static final`**修饰的成员变量**，**必须有初始化值**，一旦初始化后，在执行的过程中**其值不能再被改变**。\n\n- **命名规范**：通常使用英文单词**全部大写**，**多个单词下划线连接**起来。\n\n```java\n// 使用示例，也可以写成接口形式\n// 标识用户状态常量\npublic class UserStatus {\n    // 0 -》 正常 \n    public static final Integer USER_NORMAL  = 0;\n    // 1 -》 异常\n    public static final Integer USER_ABNORMAL  = 1;\n    // 2 -》 禁止\n    public static final Integer USER_PROHIBIT  = 2;\n}\n```\n\n类似于我们正常声明成员变量，只不过为了**保证其不可修改**的特性，加上了`public static final`修饰。\n\n**补充说明**：\n\n在我们使用常量的时候，Java会在编译阶段**自动**进行“宏替换”，也就是把使用常量的地方全部替换成真实的字面量，提高一点系统的性能。\n\n```java\n// 比如我们使用常量 UserStatus.USER_NORMAL\nSystem.out.println(UserStatus.USER_NORMAL);\n// java会在编译阶段替换为字面量 0\nSystem.out.println(0);\n```\n\n## (2) 去魔法化\n\n假设我们需要将用户的状态设置为异常状态，\n\n以前我们直接使用数字，并加上注释（可能有些人注释都懒得加）：\n\n```java\n// 设置用户状态为异常\nuser.setStatus(1); // 不推荐\n```\n\n在一个规模比较小或者使用处极少的项目中可能问题不大，但如果项目规模比较庞大，开发时间跨度大，使用处比较多，那么上述写法便非常的不友好，由此我们可以使用上述所学的常量。\n\n**常量代替：**\n\n```java\n// 还是使用我们语法介绍部分声明的常量\n// 使用变量代替魔法值，设置用户状态为异常\nuser.setStatus(UserStatus.USER_ABNORMAL); // 推荐√\n```\n\n可能会有人觉得这样写也太长了，但是对于一个有代码提示的IDE来说其实并不算什么问题，更何况它的可读性明显提高了。当我们需要修改指代状态数字时，仅仅需要在`UserStatus`类中修改一次即可处处生效。\n\n# 三.枚举\n\n虽然常量也可以达成目的，但**在一些约束性比较强的情况下，枚举类更加的适合**。例如，你期待接收已定义的常量数值，事实上程序可以接受任意符合参数类型的数值。\n\n## (1) 语法\n\n枚举是Java中的一种特殊类型，需要先创建一个枚举类再进行使用。\n\n**语法格式**：\n\n```java\n修饰符 enum 枚举名称{\n     // 罗列枚举类实例的名称，以逗号（,）分隔实例,以分号（;）标识结尾\n}\n```\n\n- 示例一：\n\n  - 对于一些简单的场景，我们可以直接使用枚举示例：\n\n  ```java\n  // ,分割实例 ;标识结尾\n  public enum SeasonEnum {\n      // 上下左右\n      UP, \n      DOWN, \n      LEFT, \n      RIGHT;\n  }\n  ```\n\n  - 调用与使用抽离到单独类中的常量类似\n\n  ```java\n  public class App {\n      public static void main(String[] args) {\n          System.out.println(SeasonEnum.UP);\n          System.out.println(SeasonEnum.DOWN);\n          System.out.println(SeasonEnum.LEFT);\n          System.out.println(SeasonEnum.RIGHT);\n      }\n  }\n  ```\n\n  - 可以看到除了枚举类内置的方法以外，我们只能使用事先罗列的枚举类实例。\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/cxqKuGE8-image.png)\n\n- 示例二：\n\n  - 对于一些稍复杂的情况，我们只使用实例仅仅能完成标识，无法完成存储等用途。由此我们还可以为每个实例**增加一个至多个值**。\n\n    ```java\n    public enum UserStatusEnum {\n        // 根据构造器枚举实例，此时不含无参构造器，必须要赋值枚举\n        NORMAL(0),\n        ABNORMAL(1),\n        PROHIBIT(2);\n    \n        // 必须提供对应参数构造器\n        UserStatusEnum(Integer value) {\n            this.value = value;\n        }\n        \n    \t// 不建议给用户提供二次修改枚举值的权限\n        // 可以有多个字段\n        private final Integer value;\n    \n        // 仅开放获取实例值权限\n        public Integer getValue() {\n            return value;\n        }\n    }\n    ```\n\n  - 使用上与上述类似，不过多了些许自定义方法,例如：getValue\n\n  ```java\n  public class App {\n      public static void main(String[] args) {\n          // 可以仅获取枚举值\n          System.out.println(UserStatusEnum.NORMAL); // NORMAL\n          // 还可以获取枚举值所指代的数值\n          System.out.println(UserStatusEnum.NORMAL.getValue()); // 0\n      }\n  }\n  ```\n\n  - 可以看到与上述类似，不过多了我们提供的获取值方法\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/raOTOXzn-image.png)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/gFWFEGnR-image.png)\n\n## (2) 特点\n\n- 枚举类都是继承了枚举类型：java.lang.Enum\n- 枚举**都是最终类，不可以被继承**。\n- 构造器都是私有的，枚举对外**不能通过**`new`**创建对象**。\n- 枚举类的**第一行默认都是罗列枚举对象的名称**的。\n- 枚举类相当于是**多例模式**。\n\n我们可以**反编译后**结合上述观察枚举的特征：\n\n![image.png](https://pic.code-nav.cn/post_picture/1619305100524748802/0NBxj8Ol-image.png)\n\n## (3) 去魔法化\n\n假设我们同样需要将用户的状态设置为异常状态：\n\n```java\n// 设置用户状态为异常\nuser.setStatus(1); // 不推荐\n// 使用常量\nuser.setStatus(UserStatus.USER_ABNORMAL); // 推荐一√\n```\n\n我们也可以使用上述所学的枚举值进行代替\n\n```java\n// 还是使用我们语法介绍部分声明的枚举值\n// 使用枚举值代替魔法值，设置用户状态为异常\nuser.setStatus(UserStatusEnum.ABNORMAL.getValue()); // 推荐二√\n```\n\n可能有人会发现这样写其实和使用没啥区别，如果仅仅是这样用确实没什么区别。但是在方法参数列表中，让枚举类当作参数那便有很强的约束性。\n\n```java\npublic class App {\n    public static void main(String[] args) {\n        setStatus(UserStatusEnum.NORMAL);\n    }\n\n    public static void setStatus(UserStatusEnum userStatus){\n        User user = new User();\n        user.setStatus(userStatus.getValue());\n    }\n}\n```\n\n这样一来我们要想设置用户状态便只能传递枚举类中已经存在的几个枚举实例。\n\n此外对于一些方法只能接受数值的情况，我们还先通过values获取所有值进行判断数值正确性,再进行处理。\n\n```java\npublic class App {\n    public static void main(String[] args) {\n        setStatus(1);\n\n    }\n\n    // 假设只能接收非枚举实例类型\n    public static void setStatus(Integer status) {\n        // 判断参数是否为对于枚举实例\n        if (isTrueValue(status)) {\n            User user = new User();\n            user.setStatus(status);\n        } else {1\n            System.out.println(\"非法参数\");\n        }\n\n    }\n\n    // 判断参数是否为对于枚举实例\n    public static boolean isTrueValue(Integer num) {\n        UserStatusEnum[] values = UserStatusEnum.values();\n        for (UserStatusEnum statusEnum : values) {\n            Integer value = statusEnum.getValue();\n            if (value.equals(num)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n虽说使用常量结合哈希也能解决上述问题，但这终究需要因情况决定用法。\n\n\n\n\n\n\n\n\n\n\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619305100524748802/SjTu2JVH-R-C.png",
        "language": null,
        "viewNum": 6,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619305100524748802",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-19T00:54:07.000+00:00",
        "updateTime": "2023-12-23T11:16:48.000+00:00",
        "user": {
          "id": "1619305100524748802",
          "planetCode": "6872",
          "userName": "观止.",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/OYu6LaaicHd8CDShMPqharTUTck82BzOggVOzdsF3AqPyVMRjAjEicQpvpQTQAeUFOvnsPuHLBTYNDWMgsg0r5LQ/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": -4,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 10,
          "coin": 100,
          "followeeNum": 9,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-01-28T13:18:24.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-28T12:03:15.000+00:00",
          "updateTime": "2023-12-20T09:18:47.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "275",
    "size": "8",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "35"
  },
  "message": "ok"
}